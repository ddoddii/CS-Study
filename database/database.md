### **1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.**

각 튜플을 구별하기 위해 모든 속성을 전부 이용하는 것보다 일부 속성을 이용해 구분하는 것이 효과적입니다. 따라서 테이블에 포함된 튜플들을 유일하게 구별해주는 역할은 속성 또는 속성들의 집합인 key 가 담당합니다.

```yml
- 슈퍼키(Super Key) : 유일성의 특성을 만족하는 속성 또는 속성들의 집합입니다.
- 후보키(Candidate Key) : 유일성과 최소성을 만족하는 속성 또는 속성들의 집합입니다.
- 기본키(Primary Key) : 여러 후보키 중에서 기본적으로 사용할 키입니다.
- 대체키(Alternate Key) : PK 로 선택받지 못한 후보키입니다. 
- 외래키(Foreign Key) : 어떤 테이블에 소속된 속성 또는 속성 집합이 다른 테이블의 기본키가 되는 키입니다. 테이블 간의 관계를 나타낼 때 사용합니다. 
```

- **기본키는 수정이 가능한가요?**
  - 기본키가 다른 테이블의 외래키에 의해 참조되는 경우 수정할 수 없습니다. 만약 연관관계가 없는 경우 수정할 수 있습니다.
- **사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?**
  - MySQL의 데이터베이스 엔진인 InnoDB는 Null이 없는 첫번째 유니크한 인덱스를 clustered index 로 사용합니다. 만약 유니크한 칼럼이 없다면, InnoDB는 인덱스를 직접 만듭니다.
- **외래키 값은 NULL이 들어올 수 있나요?**
  - 외래키는 NULL 을 허용합니다. 외래키는 단순히 부모테이블의 기본키를 참조하는 값이기 때문입니다. 따라서 중복도 허용합니다.
- **어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?**
  - 쓰기 관점과 읽기 관점이 다릅니다. 만약 칼럼에 유니크 키워드가 붙으면, 쓸 때 정말 느립니다. 왜냐하면 데이터를 넣을 때 매번 중복되는 값이 있는지 확인해주어야 하기 때문입니다. 반면 읽기는 정말 빠른데, 데이터베이스가 유니크 제약 조건이 있는 칼럼에 대해 인덱스를 생성해주기 때문입니다. 
- **Key와 index 의 차이는 무엇인가요?**
  - Key 는 테이블에 있는 튜플을 유일하게 식별하는 속성 또는 속성들의 집합입니다. Index 는 테이블에 있는 튜플을 빠르게 찾기 위한 자료구조입니다. 

### **2. RDB와 NoSQL의 차이에 대해 설명해 주세요.**

RDB는 관계형 데이터베이스로, 사전에 정의된 DB 스키마를 요구하는 테이블 기반 데이터 구조를 갖습니다. 반면 NoSQL은 테이블 형식이 아닌 비정형 데이터를 저장할 수 있습니다.

- **NoSQL의 강점과, 약점이 무엇인가요?**

  - NoSQL은 정확한 데이터 구조가 정해지지 않는 경우에 좋습니다. 또한 scale-out에 용이하므로 데이터 양이 매우 많은 경우에 유리합니다. 그러나 데이터 중복이 발생할 수 있습니다. 또환 명확한 스키마가 없으므로 명확하게 데이터 구조를 보장하지 않습니다.

- **RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)**

- **NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.**

### **3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.**

트랜잭션은 작업의 완전성을 보장해 줍니다. 즉 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않도록 만들어주는 기능입니다. 트랜잭션은 데이터의 정합성을 보장합니다. 

데이터베이스의 상태를 바꾸기 위한 연산이다. 

```yml
ACID 원칙
- Atomicity(원자성) : 트랜잭션은 모두 반영되거나 모두 반영되지 않아야 합니다.
- Consistency(일관성) : 트랜잭션 처리 전과 처리 후 데이터 모순이 없는 상태를 유지해야 합니다.
- Isolation(독립성) : 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장해야 합니다.
- Durability(지속성) : 성공적으로 수행된 트랜잭션은 영원히 반영되어야 합니다. 
```


- **트랜잭션을 사용할 때 어떤 것들을 주의해야 할까요?**
  - 첫번째로, 트랜잭션의 범위를 최소화하는 것이 좋습니다. 왜냐하면 일반적으로 데이터베이스에서 커넥션의 개수가 제한적이어서 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수는 줄어들 것입니다. 두번째로, 네트워크를 통해 원격서버와 통신하는 등 I/O 작업은 트랜잭션 내에서 제거하는 것이 좋습니다.
- **ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?**
  - DBMS가 지속성을 보장하려면, recovery 기능이 필수적입니다.  
  - Undo : 롤백을 위해 사용 , Redo : 변경된 상태에 대해 로그해 놓는 것. 
  - 첫번째로는, Write-Ahead Logging(WAL) 방법이 있습니다. 데이터베이스에 실질적으로 변경 작업을 하기 전에, DBMS는 트랜잭션에 관한 사항들을 디스크의 로그 파일에 작성합니다. 만약 failure 가 일어나도, WAL을 통해 DBMS는 트랜잭션이 반영되었음을 보장할 수 있습니다. 
- **트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?**
  - 리뷰를 작성하면 포인트를 주는 서비스 - 리뷰 작성 했는데 포인트 적립 안하면 트랜잭션을 사용해야 함. 
- **읽기에는 트랜잭션을 걸지 않아도 될까요?**
  - 조회를 여러번 하는 경우에는 Phantom Read 가 생길 수 도 있다. 

### **4. 트랜잭션 격리 레벨에 대해 설명해 주세요.**

격리 레벨이라는 것은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨입니다. MySQL에서는 4개의 레벨이 있는데, 이것은 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, 그리고 SERIALIZABLE입니다. MySQL에서는  REPEATABLE READ 를 기본으로 채택하고 있습니다. 

```text
- READ UNCOMMITTED : 커밋하지 않은 데이터를 읽을 수 있다. Dirty Read 문제가 생길 수 있다. 
- READ COMMITTED : 커밋한 데이터만 읽을 수 있다. 하지만 트랜잭션A 중 다른 트랜잭션B 에서 x의 값을 바꾸면, 트랜잭션B 전후 x값을 읽었을 때 값이 달라지는 문제가 생길 수 있다. 이것을 Non-Repeatable Read 라고 한다.
- REPEATABLE READ : 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있다. 하지만 여기서도 한 트랜잭션 내에서 같은 쿼리를 두 번 실행했는데, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상인 Phantom Read 가 발생할 수 있다.
- SERIALIZABLE : 트랜잭션을 그냥 순차적으로 진행시킨다. 가장 엄격한 격리 수준을 가지며 동시 처리 성능이 매우 떨어진다.
```

- **모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?**
  - 모든 DBMS 가 4개의 레벨을 모두 구현하고 있지는 않습니다. 높은 격리 레벨일 수록 데이터의 정합성은 보장하지만, 동시성을 희생해야 하기 때문입니다. DBMS의 디자인 철학에 따라 지향하는 점이 다릅니다. 예를 들어, MySQL의 InnoDB는 4개의 격리 레벨을 모두 지원하지만, SQLite 는 SERIAZIALE 만 지원합니다. 
- **만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.**
  - InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML(insert,update,delete) 로 변경되기 이전 버전의 데이터를 별도로 백업 합니다. 이렇게 백업된 데이터를 Undo log 라고 합니다. 
  - MySQL 에서는 쓰기 작업이 바로 디스크 영역에 반영되는 것이 아니라 버퍼 풀에 들어갑니다. 따라서 트랜잭션이 비정상적으로 종료되었을 때 데이터베이스의 Durability(영속성)을 보장하기 위해 Redo log를 사용합니다. 
- **그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?**
  - 스토리지 엔진 (데이터베이스 엔진)은 데이터베이스에서 데이터를 어떻게 물리적으로 저장하고 접근할 것인지를 담당하는 컴포넌트입니다. 물리적 데이터 관리로부터 시작된 데이터 삽입, 업데이트, 삭제 요청등을 처리하며 메모리, 인덱스 등의 관리를 합니다. 엔진마다 접근 속도, 트랜잭션 기능 지원 정도에 차이가 있습니다.
- **언제 동시성이 가장 잘 보장 가능하고, 격리성이 가장 낮은 레벨을 사용할 수 있을까요?**
  - 조회수의 경우 사용할 것 같습니다. 어플리케이션 상 크게 문제가 없는 로직이므로. 몽고디비 같은 경우 실제 READ UNCOMMITED 쓴다. 

### **5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.**

인덱스는 데이터베이스 테이블에서 튜플을 빠르게 찾게 위해 사용하는 추가적인 자료구조입니다. 인덱스 조건을 칼럼에 걸게 되면, InnoDB에서 B-tree, Hash table 등 새로운 자료구조를 생성하여 디스크 공간에 저장합니다. 

- **일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?**
  - 튜플이 삽입,수정,삭제되면, 해당 인덱스 또한 업데이트 되어야 합니다. Write 연산이 잦으면 인덱스 또한 자주 업데이트 해줘야 하고 오버헤드가 발생할 수 있습니다. 또한 인덱스는 따로 물리적으로 저장해야 하므로 저장용량을 차지합니다. 
- **앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?**

- **ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.**
  - 인덱스가 존재하지 않는 경우 : ORDER BY 는 데이터베이스 정렬을 위해 해당 열의 모든 값을 풀 스캔하고, 메모리나 디스크에 정렬 알고리즘을 적용합니다. GROUP BY 의 경우 지정된 열을 기준으로 데이터를 그룹화하고, 각 그룹에 속하는 행을 찾기 위해 데이터를 스캔합니다.
  - 인덱스가 존재하는 경우 : 인덱스가 ORDER BY 절에 사용된 열에 존재하는 경우, 데이터베이스는 인덱스 트리를 사용하여 정렬된 순서로 행을 반환할 수 있습니다. GROUP BY 절에 지정된 열에 인덱스가 존재하는 경우에도 데이터베이스는 인덱스를 활용하여 그룹화를 수행할 수 있습니다.(이미 정렬되어 있기 때문 - ex. 1,1,2,2,3)
- **기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?**
  - 기본키를 설정하면, DBMS 는 PK 칼럼에 대해 유니크 인덱스를 생성하고, 유니크 제약조건을 겁니다. 인덱스와 기본키의 차이는 여러 가지 있습니다. 우선 기본키의 용도는 테이블 내 튜플을 식별하는 용도입니다. 반면 인덱스는 튜플을 빠르게 검색하기 위한 용도입니다. 따라서 PK 는 중복을 허용하지 않지만 인덱스가 걸린 칼럼은 중복이 있어도 됩니다. 테이블 내에 기본키는 딱 한개이지만, 인덱스는 여러 개 존재할 수 있습니다. 
- **그렇다면 외래키는요?**
  - MySQL 의 InnoDB 에서는 외래키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스를 생성합니다. 
  - 외래키 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생하는 경우도 있습니다. 
- **인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?**
  - MySQL의 InnoDB 같은 경우, 기본키는 자동적으로 클러스터링 인덱스로 저장됩니다. 이때 기본키 값 순서대로 정렬되어 디스크에 저장됩니다. 세컨더리 인덱스의 경우, 실제 테이블과는 따로 저장됩니다. 
  - 실제 데이터가 저장되는 순서는 DBMS 에 따라 다를 수 있습니다. MySQL의 InnoDB 의 경우 클러스터링 인덱스 + 세컨더리 인덱스 방식을 사용합니다. 기본키가 클러스터링 인덱스가 되고 실제 데이터 튜플의 물리적 순서를 결정합니다. 세컨더리 인덱스는 기본키 말고 다른 인덱스에 해당하며, 테이블 외 따로 저장됩니다. 만약 쿼리가 데이터를 찾을 때 세컨더리 인덱스를 사용하면, InnoDB 는 우선 세컨더리 인덱스를 찾고, 기본키의 값을 논리적인 주소로 사용하여 데이터를 검색합니다.
- **우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?**

- **(A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?**
  - (A,B) 로 인덱스를 설정시, A열을 먼저 정렬하고 그 다음 B 열을 정렬합니다. 만약 B조건만 사용하는 쿼리라면 (A,B)가 효율적으로 활용되지 않을 것입니다.


### **6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.**

```yml
- Clustering: 여러개의 DB를 수평적인 구조로 구축하는 방식, 동기로 데이터 무결성을 유지한다.
- Replication: Master(Write담당)-Slave(Read 담당) 구조 같이 여러개의 DB를 권한에 따라 수직적으로 구축하는 방식, 비동기로 데이터 무결성 검사를 하지 않는다.
```

- **이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?**
- **마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?**
- **다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.**
- **샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?**

### **7. 정규화가 무엇인가요?**

관계형 데이터베이스 설계에서 중복을 최소화하여 무결성을 유지하도록 하는 것입니다.

- **정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.**
  - 삽입 이상(Insertion Anomaly) : 새로운 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 상황입니다.
  - 삭제 이상(Deletion Anomaly) : 하나의 데이터를 삭제할 때 관련된 데이터도 함께 삭제되어 정보 손실이 발생하는 상황입니다.
  - 수정 이상(Update Anomaly) : 데이터의 중복으로 인해 한 데이터를 여러 곳에서 수정해야 하며, 일부만 수정될 경우 데이터의 불일치(일관성 문제)가 발생할 수 있는 상황입니다.
- **각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.**
  - 1정규형 전/후
    - 전: 테이블에는 중복된 레코드가 존재할 수 있고, 하나의 필드 내에 여러 값이 저장될 수 있습니다(비원자적 값). 예를 들어, 하나의 레코드에서 '취미' 필드에 ["독서", "영화감상"] 같이 여러 취미를 배열이나 문자열로 저장할 수 있습니다.
    - 후: 각 필드의 값은 원자적이 되어야 합니다. 즉, 하나의 필드에는 하나의 값만을 가집니다. '취미' 정보를 저장하기 위해서는 취미마다 별도의 레코드를 추가해야 하며, 이는 테이블의 구조를 변경하여 각 취미가 별도의 레코드로 분리됩니다.
  - 2정규형 전/후
    - 전: non-key 속성들이 PK 와 연관되어 있다.
    - 후 : 각 non-key 속성은 PK 전체에 의존해야 한다.
  - 3정규형 전/후
    - 전 : non-key 속성이 다른 non-key 속성에 의존한다.
    - 후 : 모든 non-key 속성은 오로지 key에만 의존한다.
- **정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.**
  - DB 정규화는 테이블을 많이 나누게 하고, 테이블이 많아지면 Join 연산이 많아집니다. Join 은 성능에 큰 악영향을 미칩니다. 또한 정규화는 쓰기에 최적화되어 있습니다. 하지만 데이터베이스 연산은 읽기가 훨씬 많은 비중을 차지합니다.
  - 데이터를 읽기 위해서는 join 연산을 해야하는데, 다른 연산에 비해 부하가 높은 연산입니다.

### **8. View가 무엇이고, 언제 사용할 수 있나요?**

View 는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블에서 유도된, 이름을 가지는 가상 테이블입니다. 뷰는 저장장치 내에 물리적으로 존재하지는 않습니다. 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 보호할 수 있습니다. 뷰를 사용하면 기본 테이블 구조가 변경되어도 응용 프로그램은 계속 동일한 뷰를 사용할 수 있어서, 데이터 독립성을 제공합니다.

- **그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?**
  - View 의 종류에 따라 다릅니다. Updatable View 에서는 데이터를 수정,삽입,삭제하면 기본 테이블에도 반영됩니다. Read-Only View 에서는 데이터를 수정할 수 없습니다.

### **9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.**

DB Join 은 두 개 이상의 테이블에서 관련된 데이터를 결합하여 의미 있는 정보를 얻기 위해 사용되는 연산입니다. 조인은 테이블 간의 공통 열(일반적으로 기본 키와 외래 키)을 기반으로 수행됩니다.

Join 의 종류는 다음과 같습니다.

```text
- Inner Join
  - 두 테이블에서 조인 조건을 만족하는 행만 반환합니다.
- LEFT OUTER JOIN
  - 왼쪽 테이블의 모든 행을 반환하고, 오른쪽 테이블에서 조인 조건을 만족하는 행을 함께 반환합니다.
- RIGHT OUTER JOIN 
  - 오른쪽 테이블의 모든 행을 반환하고, 왼쪽 테이블에서 조인 조건을 만족하는 행을 함께 반환합니다.
- FULL OUTER JOIN 
  - 왼쪽 및 오른쪽 테이블의 모든 행을 반환합니다.
- CROSS JOIN
  -  테이블의 모든 행을 결합하여 가능한 모든 조합을 반환합니다.
- SELF JOIN
 - 하나의 테이블 내에서 자기 자신과 조인하는 것을 의미합니다.
```

- **사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.**
  - 주요한 네 가지 조인 알고리즘으로는 **Nested Loop Join, Hash Join, 그리고 Sort Merge Join, Index Join**이 있습니다. Nested Loop Join 은 마치 이중 for문과 같은 원리입니다. Sort Merge Join 은 각 테이블을 각 칼럼에 대해 정렬해놓은 후 join 합니다. Hash Join 같은 경우 내부테이블에 대해 해시 속성을 만들고 외부 테이블에 대해 해시값이 있는지 판별하고 조인합니다. 
- **그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?**
  - EXPLAIN (또는 EXPLAIN PLAN) 명령을 사용할 수 있습니다. 대부분의 DBMS는 EXPLAIN 명령을 제공하여 쿼리 실행 계획을 확인할 수 있습니다. 쿼리 앞에 EXPLAIN을 붙여 실행하면, 쿼리 옵티마이저가 선택한 실행 계획을 볼 수 있습니다. 실행 계획에는 사용된 조인 알고리즘, 조인 순서, 인덱스 사용 여부 등의 정보가 포함됩니다.
- **앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?**
  - 네, 조인의 성능은 인덱스의 유무에 큰 영향을 받습니다. 적절한 인덱스를 사용하면 조인 연산의 속도를 크게 향상시킬 수 있습니다. 인덱스가 조인 성능에 미치는 영향은 다음과 같습니다. 
  - Nested Loop join 은 오른쪽에 있는 테이블을 계속 스캔해야 하는데, 인덱스가 있는 경우에는 굳이 정렬할 필요 없이 조인을 수행할 수 있기 때문에 성능상 이점이 있습니다.
- **3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.**
  - 먼저 2개 테이블 조인 하고, 그 결과와 남은 테이블에 대한 조인을 합니다. 먼저 조인을 하는 테이블을 선택하는 것에 따라 성능이 많이 달라집니다.

### **10. B-Tree와 B+Tree에 대해 설명해 주세요.**

B-Tree, B+Tree 모두 트리 구조입니다. 자가균형 트리여서 삽입,수정,삭제 O(logn) 이다. 트리 구조는 탐색을 단시간 내에 할 수 있게 해줍니다. B-Tree 의 핵심은 데이터가 정렬된 상태로 되어 있다는 것입니다. B+Tree 는 B-Tree 에 비해 발전된 구조인데, B-Tree 는 브랜치에도 데이터를 저장하는 반면 B+Tree 는 리프노드에만 데이터를 저장합니다.

하드 디스크에서 메모리로 데이터를 불러올 때 블럭 단위로 가져오는데 B+Tree 는 브랜치에는 실제 데이터가 없고 키값만 있어서, 하나의 블럭에 더 많은 노드를 가져 올 수 있어 공간지역성 때문에 캐시 히트를 높일 수 있습니다.

또한 B+Tree 는 리프 노드에 데이터가 모두 있기 때문에 한번의 선형탐색만 하면 되어서 모든 노드를 확인해야 하는 B-Tree 에 비해 빠릅니다.

삽입하고 삭제할 때 B+Tree 가 오버헤드가 더 적습니다. 왜냐하면 B-Tree 의 경우 데이터까지 모두 업데이트 해야 하기 때문입니다.

Range 검색의 경우에도 B+Tree 가 유리하다. 


- **그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?**
  - B-Tree 중간에서 찾을 수 있어서 적중률이 낮아서 안좋지만, B-Tree 같은 경우에는 중간에 찾을 수 있습니다. 하지만 생각보다 중간노드에서 찾는 경우에는 적중률이 낮습니다. 
- **DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?**
  - RBT가 더 복잡해서 구현하는데 어렵다. RBT 는 BST 여서 바이너리인데, 접근성이 더 낮습니다.
- **오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.**
  - B-Tree는 연결이 안되어있다. B+Tree 는 리프 노드가 링크드 리스트 형태로 연결되어 있습니다. 

### **11. DB Locking에 대해 설명해 주세요.**

데이터베이스는 여러 사용자들이 같은 데이터를 동시에 접근하는 상황에서, 데이터의 무결성과 일관성을 지키기 위해 락을 사용합니다.

- **Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.**
- **물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?**



### **12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?**

- **DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?**

### **13. Schema가 무엇인가요?**

- **Schema의 3계층에 대해 설명해 주세요.**

### **14. DB의 Connection Pool에 대해 설명해 주세요.**

커넥션풀은 어플리케이션 로딩 시점에 커넥션 객체를 미리 생성하고, 어플리케이션에서 데이터베이스 연결이 필요한 경우 미리 준비된 커넥션 객체를 사용하는 것입니다. 이것은 커넥션을 매번 생성하는 비용을 아낄 수 있습니다. 또한, 연결을 받는 데이터베이스 쪽의 상황도 고려해줄 수 있습니다. 데이터베이스는 일반적으로 확장성이 떨어지는데, 데이터베이스가 맺을 수 있는 커넥션 수도 고려하여 어플리케이션 상에서 커넥션 풀을 생성해야 합니다.

- **커넥션은 어떠한 자원을 차지하나요?**
  - 커넥션을 맺는다는 것은 특정 포트로 들어오는 값을 내가 사전에 정의한 어떠한 값이라고 약속한 개념을 운영체제가 기억하고 있는 것입니다. 운영체제는 이러한 약속을 파일로 남깁니다. 실제로 리눅스에서는 네트워크를 전송하는 과정이 실제 파일에 write 하는 것과 똑같습니다. I/O 가 네트워크를 타고 가면 커넥션이 되는 것이고, 실제 파일로 쓰는 것이면 디스크 I/O가 발생하는 것인데 보통 파일 개수 제한이 있습니다.

- **DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.**
  - 원래 커넥션 풀이 없으면 TCP 기반 커넥션을 생성하기 때문에, 시간이 오래 걸립니다. 따라서 커넥션 풀을 생성해 놓는 방식으로 커넥션을 구성합니다. 

- **MySQL 은 "one-thread-per-connection" 구조입니다. 이때, 커넥션 풀과 쓰레드 풀의 차이는 무엇인가요?**

- **백엔드 서버와 데이터베이스가 소통하는 경우, 클라이언트는 백엔드 서버가 되고, 서버는 데이터베이스가 됩니다. 이 경우 클라이언트 측에서 쓰레드 풀이 있는 경우에도 커넥션풀을 별도로 세팅해야 할까요?**



### **15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.**

- **가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?**
- **COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(\*), COUNT(column) 의 동작 과정에는 차이가 있나요?**

### **16. SQL Injection에 대해 설명해 주세요.**

- **그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?**
