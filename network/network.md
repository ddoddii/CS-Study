### Computer Network

<details>
<summary>📚 공부한 자료</summary>

- 네트워크 하향식 접근
- HTTP 완벽 가이드
- 성공과 실패를 결정하는 1%의 네트워크 원리

</details>

### 1. 쿠키와 세션의 차이에 대해 설명해 주세요.

**쿠키**는 클라이언트 측에서 사용자의 브라우저에 저장되는 작은 데이터 조각입니다. 쿠키는 클라이언트의 인증을 도와줍니다. 클라이언트 로컬에 저장하기 때문에 변질되거나 노출될 위험이 있습니다. 반면, **세션**은 서버 쪽에서 사용자의 정보를 저장합니다. 쿠키를 사용하지만, 쿠키에 세션ID를 저장하여 클라이언트에게 보냅니다. 세션을 서버에서 관리하기 때문에 비교적 보안성이 높습니다.

- **세션 방식의 로그인 과정에 대해 설명해 주세요.**

  1. 클라이언트가 서버에게 로그인 정보가 들어있는 파라미터와 함께 login 요청을 한다.
  2. 서버에서 login인증을 하고 정보가 올바르면 세션 객체를 생성하고 세션 Id를 Set-cookie를 통해 클라이언트에게 전달한다.
  3. 세션 객체는 서버에 저장해놓는다.
  4. 클라이언트가 서버에 작업을 요청할 때 요청 헤더에 세션 Id가 같이 전달된다(쿠키이므로 통신시 계속 왔다갔다함)
  5. 서버에서는 클라이언트로부터 받은 요청헤더에 세션Id를 확인해서 세션 객체를 검색하고 정보가 있으면 요청한 작업에 대해 응답해준다.
  6. 로그아웃 시 세션을 종료한다.

- **HTTP의 특성인 Stateless에 대해 설명해 주세요.**
  - HTTP 프로토콜은 **Stateless**로 설계되었습니다. 이는 각 요청이 독립적이며 서로 연결되어 있지 않다는 것을 의미합니다. 서버는 클라이언트의 이전 상태나 요청 정보를 기억하지 않습니다. 이로 인해 웹은 기본적으로 사용자의 상태 정보를 유지하지 않는 환경입니다.
- **Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?**

  - Stateless 는 구현이 단순하고, 서버의 확장성이 좋아지고, 각 요청과 응답이 독립적이므로 응답을 캐시에 저장하고 재사용하는 것이 가능하다는 여러 장점이 있습니다. 그러나, 이전 요청과 이후 상태 사이에 상태를 유지하지 않기 때문에 사용자의 로그인 등 상태를 유지해야 할 때를 위해 세션과 쿠키를 구현한 것입니다.

- **Stateless의 경우 왜 확정성이 좋다고 할까요?**

  - Stateful 한 경우에는 클라이언트가 서버에 접속하면 특정 서버와 계속 연결 상태에 있어야 하는데 이 부분을 관리하기 힘듭니다. 반면 Stateless 한 경우 클라이언트는 서버와 아무런 연결 고리가 없기 때문에 요청을 보낼 때마다 아무 서버나 서비스할 수 있는 구조기 때문에 웹서버를 확장한다고 했을 때 고려할 사항이 줄어듭니다.

- **규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?**

  - 로드 밸런싱으로 인한 분산 처리에서는 세션 저장소가 일치하지 않아서 세션 불일치 문제가 발생할 수 있습니다. 이를 해결하기 위한 방법은 크게 3가지가 있습니다.
    1. Sticky Session
       클라이언트의 요청을 하나의 서버로 고정시키는 방식입니다. 하지만 특정 서버에 장애가 발생하면 해당 서버로 요청을 보내는 모든 사용자들의 세션 정보를 잃게 되는 단점이 있습니다. 또한, 사용자들이 하나의 서버로 몰리게 되면 과부하가 발생할 수 있습니다.
    2. Session Clustering
       클러스터링은 여러 대의 서버들이 연결되어 하나의 시스템처럼 동작하는 것을 의미합니다. 대표적으로 Tomcat 은 클러스터링을 위해 all-to-all 세션 복제 방식을 사용합니다. 사용자의 세션이 업데이트 될 때마다 Tomcat의 DeltaManager가 다른 모든 서버에 해당 세션의 정보를 복제 합니다. 하지만 서버의 수가 늘어날 수록 많은 메모리가 필요하고, 세션이 복제되는 와중에는 세션 불일치 문제가 생길 수 있습니다.
    3. Session Storage
       각각의 서버에 세션 정보를 저장하는 것이 아니라 외부에 저장소를 만들고 이 서버에 모든 데이터를 저장하는 방법입니다. **Redis** 같은 In-memory(인메모리) 데이터 저장소를 사용함으로써 빠르게 세션을 조회할 수 있습니다.

- **토큰 기반 방식은 어떤 장점이 있을까요?**
  - 토큰 기반 방식에서는, 사용자가 브라우저에 아이디/비밀번호를 입력하면, 인증 서버에서 그 정보를 가지고 토큰을 발급해줍니다. 그러면 브라우저는 그 토큰을 가지고 인증을 받을 수 있고, 리소스 서버에서 원하는 요청할 수 있습니다. 
  - 서버에서 세션을 저장할 필요가 없으므로, 서버는 완전히 stateless 하며 확장(scalability)하기 쉽습니다. 
  - 토큰에 선택적인 권한만 부여하여 발급할 수 있고, OAuth 의 경우 소셜 계정을 이용하여 다른 웹사이트에서도 로그인 할 수 있습니다. 따라서 로그인 정보가 사용되는 분야가 쉽게 확장될 수 있습니다.

### 2. HTTP 응답코드에 대해 설명해 주세요.

- **401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?**
  - 401은 요청이 인증이 필요로 한다는 것을 의미합니다. 이때는 인증 정보를 제공하면 접근이 허용될 수 있습니다. 403은 서버가 요청을 이해했으나, 권한 부족을 이유로 그 요청을 거부한다는 것을 의미합니다. 즉 사용자가 인증을 성공적으로 완료했음에도 요청한 자원에 대한 접근 권한이 없을 때 나타납니다.
- **200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.**
  - 200은 클라이언트 요청이 성공적으로 처리되었음을 나타냅니다. 201은 클라이언트의 요청으로 새로운 리소스가 생성되었음을 알려줍니다. 
- **필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.**
  - 네 응답코드를 만들 수 있습니다. 그러나 고려해야 할 점들이 있습니다. 표준 HTTP 응답 코드는 널리 알려져 있고, 다양한 HTTP 클라이언트에서 널리 지원됩니다. 직접 정의한 응답 코드는 이런 표준화된 환경과 호환되지 않을 수 있으며, 다른 사람들이 이해하지 못할 수 있습니다. 


### 3. HTTP Method 에 대해 설명해 주세요.

- **HTTP Method의 멱등성에 대해 설명해 주세요.**
  - 멱등성이란, 첫번째 수행을 한 뒤 여러 차례 적용해도 결과를 변경시키지 않는 작업입니다. GET,PUT, DELETE 요청은 멱등성을 보장하는 반면, POST, PATCH 요청은 보장하지 않습니다. 이렇게 멱등하지 않은 메서드에 멱등성을 제공하려면 서버에서 멱등성을 구현해야 합니다. 예를 들어 토스에서 송금하는 요청은 멱등성이 보장되지 않는 요청인데, 이것을 인지하고 멱등성을 보장하도록 처리하는 것이 중요합니다.
  - 멱등성은 요청의 재시도 때문에도 중요합니다. HTTP요청이 멱등하다면, 요청이 실패한 경우에도 주저없이 재시도 요청을 하면 됩니다. 하지만 HTTP 요청이 멱등하지 않다면, 리소스가 이미 처리되었는데 중복 요청을 보내 결과가 달라질 수 있습니다.
- **GET과 POST의 차이는 무엇인가요?**
  - GET은 URI로 지정한 정보를 도출합니다. GET 요청은 멱등성을 가집니다. POST는 폼에 데이터를 사용해서 웹 서버에 송신하는 경우에 사용합니다. POST에서는 데이터가 HTTP 메세지의 바디 부분에 포함되어 있습니다. POST는 멱등성을 가지지 않습니다. 
- **POST와 PUT, PATCH의 차이는 무엇인가요?**
  - POST는 주로 서버에 새 리소스를 생성할 때 사용됩니다. PUT는 지정된 URI에 리소스를 생성하거나, 이미 존재하는 경우 해당 리소스를 대체합니다. PATCH 는 리소스를 수정하고, 기존 리소스에 응답을 추가하는 경우에도 사용됩니다. 
  - POST, PATCH는 멱등하지 않고, PUT은 멱등합니다. PATCH 의 경우 리소스에 응답을 추가하는 경우에도 사용되어 멱등하지 않습니다. PUT의 경우 같은 요청을 N번 호출하여도 항상 대상 리소스를 대체하여 동일한 상태로 만들기 때문에 멱등합니다.
- **HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?**
  - HTTP GET은 서버로부터 정보를 검색하기 위해 사용하며, 그 과정에서 서버의 상태를 바꾸지 말아야 합니다. 데이터를 URL의 쿼리 스트링으로 전달하는 것이 이 의도와 가장 부합합니다. GET 요청의 본문에 데이터를 포함시키는 것은 GET의 의도와 부합하지 않습니다.

### **4. HTTP에 대해 설명해 주세요.**

HTTP는 인터넷에서 데이터를 주고받기 위한 프로토콜입니다. Request-Response 모델을 따르고, 무상태 프로토콜입니다. TCP/IP 기반입니다. 

- **공개키와 대칭키에 대해 설명해 주세요.**
  - 공개키와 대칭키는 암호화 통신에서 사용되는 2가지 주요 암호화 방식입니다. 대칭키는 암복호화에 동일한 키가 사용됩니다. 하지만 대칭키가 탈취당하면 심각한 문제가 발생합니다. 따라서 암복호화에 있어서 다른 키(개인키, 공개키)가 사용되는 공개키 방식이 고안되었습니다.
  - 공개키 방식을 설명하기 위해, 네이버와 통신을 한다고 가정해 봅시다. 이때 네이버에서 개인키를 가지고 있고, 공개키를 대중에게 공개합니다. 사용자는 공개키로 아이디,비밀번호를 암호화합니다. 해당 공개키가 실제 네이버의 공개키가 맞는지 검증은 Certificate Authority(CA)가 해줍니다. 
  - 브라우저는 서버를 완전히 신뢰하지 못하기 때문에 핸드셰이크 과정을 거치는데, 브라우저 측에서 랜덤 데이터를 생성해서 서버에게 보냅니다. 서버는 답변으로 랜덤 데이터와 해당 서버의 인증서를 보냅니다. 클라이언트는 인증서가 진짜인지 브라우저에 내장된 CA들의 정보를 통해 확인하게 됩니다. CA의 인증을 받은 인증서는 CA의 개인키로 암호화되어 있는데, CA의 공개키로 복호화된다면 실제 인증서임을 확인할 수 있습니다. 이 인증서에는 서버의 공개키가 포함되어 있습니다. 
  - 실제 데이터 전송과정에서는 대칭키와 공개키 방식이 혼합되어 사용됩니다. 공개키 방식은 리소스를 훨씬 더 많이 사용합기 때문입니다. 데이터는 대칭키로 암호화하는데, 이 대칭키를 주고받을 때 공개키 방식을 사용합니다. 핸드셰이크 과정에서 생성된 무작위 데이터를 혼합해서 임시 키를 만들고, 임시키는 서버의 공개키로 암호화되어서 서버로 보내진 다음 양쪽에서 동일한 대칭키가 만들어집니다. 이후에는 대칭키로 암복호화 과정을 거칩니다. 

- **왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?**
  - 인증서는 서버의 공개키가 실제 서버에서 보낸, 신뢰할 수 있는 공개키인지 확인하기 위해 사용합니다. 
  - SSL 핸드셰이크 과정은 다음과 같이 이루어집니다. 
    1. 클라이언트가 서버에게 말 건냄 
      이때 브라우저는 TCP 3-way handshake 를 통해 웹 서버가 HTTPS 를 사용한다는 것을 알게 되어, [브라우저가 사용하는 SSL정보, 암호화방식, 임의의 난수] 등을 서버에게 보냅니다.
    2. 서버가 응답함
      서버는 [서버가 선택한 암호화 방식, 서버의 공개키가 포함된 SSL인증서, 임의의 난수, 클라이언트의 인증서 요청] 를 클라이언트에게 보냅니다.
    3. 클라이언트가 서버의 SSL 인증서 확인 
      브라우저에는 검증된 CA들의 정보 및 CA가 만든 공개키가 이미 설치되어 있습니다. 서버가 보낸 SSL 인증서를 내장된 CA공개키로 복호화하여, 정말 CA가 만든 것이 맞는지 확인합니다. 
    4. 클라이언트가 클라이언트의 난수 + 서버의 난수를 이용해 premaster secret 생성
      클라이언트는 이전에 생성했던 난수들을 이용해 premaster secret을 생성하고, SSL 인증서에 딸려온 웹서버의 공개키로 premaster secret을 암호화합니다. 이것을 웹서버에게 다시 전송합니다.
    5. 서버는 premaster secret을 복호화
      서버는 premaster secret을 자신의 개인키를 사용해 복호화합니다. 이를 사용해 세션키를 생성합니다. HTTPS 에서는 이 세션키를 대칭키로 사용합니다. 

- **SSL과 TLS의 차이는 무엇인가요?**
  - SSL(Secure Socket Layer), TLS(Transport Layer Security) 둘 다 일반적인 인터넷 통신에 안전한 계층을 추가하여, 암호화 통신을 하기 위한 프로토콜입니다. SSL을 기반으로 개선되어 나온 프로토콜이 TLS입니다. 
  - SSL 인증서 관련 프로세스에는 여러 기술이 있습니다. 대칭키 암호화, 공개키(비대칭키) 암호화, 신분 확인, 디지털 서명, 디지털 서명을 해주는 인증기관(CA), 공개키를 안전하게 전달하고 공유하기 위한 프로토콜, 암호화된 메세지의 변조 여부를 확인하는 무결성 알고리즘입니다.


### **5. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.**

1) 프로토콜
소켓 통신은 TCP 또는 UDP 프로토콜을 직접 사용합니다. 반면 웹소켓은 HTTP 위에서 동작하는 응용 계층 프로토콜입니다. 
2) 연결 방식
소켓 통신은 클라이언트-서버 모델이며, 서버에서 포트를 열어 클라이언트의 연결 요청을 기다립니다. 웹 소켓은 브라우저와 웹서버 사이에서 양방향 통신 채널을 제공합니다.
3) 통신 방식
소켓 통신은 스트림 기반의 양방향 통신이 가능합니다. 웹 소켓은 메세지 기반의 양뱡향 통신을 지원합니다.
4) 보안 
소켓 통신은 자체적으로 보안 기능이 없어서 SSL/TLS와 같은 보안 프로토콜을 사용해야 합니다. 웹 소켓은 HTTP 위에서 동작하므로 HTTPS 를 통해 자동으로 보안이 제공됩니다.
5) 연결 유지
소켓 통신에서는 연결 유지를 위해 별도의 메카니즘이 필요하지만, 웹소켓에서는 연결 자체가 지속적으로 열려 있어 별도의 메카니즘이 필요하지 않습니다.

웹소켓은 실시간 양방향 통신이 필요한 웹 애플리케이션에 적합하며, 소켓 통신은 더 낮은 수준의 네트워크 프로그래밍에 활용됩니다.

- **소켓과 포트의 차이가 무엇인가요?**
  - 소켓은 네트워크 통신을 위한 인터페이스 입니다. 소켓은 응용 프로그램과 전송계층(TCP 또는 UDP) 사이를 중개하며 데이터를 주고받을 수 있게 해줍니다.
  - 포트는 하나의 호스트 내에서 프로세스 또는 네트워크 서비스를 구분하는 논리적 번호입니다. 
  - 하나의 소켓에는 하나의 포트 번호가 할당되지만, 하나의 포트 번호에 여러 개의 소켓이 바인딩 될 수 있습니다. 소켓은 포트 번호를 사용하여 특정 서비스와 통신합니다.
- **여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?** 
  - 네. 같은 호스트 내에서 각 소켓은 고유한 포트 번호를 가져야 합니다. 
- **사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?**
  - 소켓이 무한정 생성될 수는 없습니다. 운영체제에서는 열 수 있는 소켓의 개수에 제한을 두고 있는데, 너무 많은 소켓이 생성되면 메모리 부족 및 CPU 과부하가 발생할 수 있습니다.

### **6. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?**

HTTP/2 가 HTTP/1.1 에 비해 훨씬 빠르고 효율적인데, 크게 4가지 이유가 있습니다. 첫번째로는 **우선순위 지정**입니다. 웹에서 우선순위는 컨텐츠가 로드되는 순서를 나타냅니다. HTTP/2 에서 개발자는 우선순위 지정을 직접 세부적으로 제어하여, 사용자가 인지하는 페이지 로드 속도를 최대화할 수 있습니다.

두번째로는 **멀티플렉싱**입니다. HTTP/1.1은 리소스를 차례로 로드하므로 한 리소스를 로드할 수 없는 경우 그 뒤에 있는 다른 모든 리소스가 차단됩니다. HTTP/2 는 물리적으로 단일 TCP 연결을 사용하여 한번에 여러 개 논리적 데이터 스트림을 보낼 수 있어서, 한 리소스 때문에 다른 리소스가 차단되지 않습니다.

세번째는 **서버 푸쉬** 입니다. HTTP/2는 클라이언트가 요청하기 전에 서버가 클라이언트에 콘텐츠를 "푸시"할 수 있습니다.

네번째는 **헤더 압축**과 **바이너리 프레이밍** 입니다. HTTP/2는 HTTP 헤더 패킷에서 중복 정보를 제거하는 HPACK이라는 고급 압축 방법을 사용하여 HTTP 패킷을 더 작게 만들었습니다. 또한, 원래 HTTP/1.1 에서는 요청,응답 메세지를 텍스트 형식으로 전달했었는데, HTTP/2.0 에서는 프레임 단위로 나누어지고 바이너리 형식으로 인코딩해서 파싱,전송 속도가 더 빨라졌습니다.

- **HTTP의 HOL Blocking 에 대해 설명해 주세요.**

  - HTTP/1.0 에서는 매 요청마다 연결/해제의 과정이 있었어서, 이로 인해 많은 오버헤드가 발생했습니다. 따라서 HTTP/1.1 에서는 이를 해결하기 위해 두 개의 연결방식이 추가되었습니다. 그것은 Persistent connection(지속적 연결) 모델과 더 발전한 HTTP pipelining 이었습니다.
  - Pipelining 방식에서는 클라이언트는 요청을 응답에 상관없이 보내고 서버는 응답을 요청이 들어온 순서대로 보내줍니다. 만약 클라이언트에서 1,2,3 번 요청을 보냈는데 각각 1번은 100초 2번은 20초 3번은 10초가 소요되는 요청이었을 때, 2,3번 요청은 이미 처리가 되었지만 1번을 먼저 응답 보내야 하므로 2,3번 응답은 계속 블로킹 됩니다. 이것이 HTTP/1.1의 HOL Blocking 입니다.

- **HTTP/2 에서는 HOL Blocking 이 발생하나요?**

  - HTTP/2 의 경우 요청은 하나의 연결에서 병렬적으로 보낼 수 있습니다. 따라서 1,2,3번 요청을 보내서 1번 요청이 처리하는 중이어도 2,3번 요청의 응답은 먼저 보내줄 수 있습니다.
  - 그러나 HTTP/2 는 TCP 를 사용합니다. TCP는 전송한 패킷이 손실되었으면 재전송을 합니다. 이때 패킷의 순서가 역전되지 않게 후속 패킷은 대기합니다. 따라서 TCP 수준에서의 HOL은 발생합니다.

- **HTTP/3.0의 주요 특징에 대해 설명해 주세요.**

  - HTTP/3 은 HTTP Over QUIC 입니다. QUIC는 UDP 위에서 구현되었고, 멀티플렉싱과 보안을 지원하는 전송 레이어 프로토콜입니다. TCP는 패킷의 순서를 보장하는 프로토콜이기 때문에 HOL 블로킹 문제가 생기는데, 따라서 최소한의 기능만 있는 UDP를 바탕으로 신뢰성을 보장해줄 수 있는 QUIC 프로토콜을 만들었습니다.

- **QUIC 는 왜 생겼나요?**

  - HTTP/1.0, HTTP/1.1, HTTPS, HTTP/2 모두 TCP 를 사용합니다. HTTPS와 HTTP/2 는 보안을 위해 TLS 도 사용합니다. 이것은 2개의 핸드셰이크 지연을 발생시킵니다. 또한, TCP를 이용한 연결은 필연적으로 HOL 블로킹을 발생시킵니다. 처음에는 TCP 프로토콜을 업데이트 하려 했으나, TCP 프로토콜은 OS 커널에서 구현되었기 때문에 사용자의 OS 를 업데이트 하는 것은 현실적으로 어려웠습니다. 따라서 UDP 를 바탕으로 하는 QUIC 를 만들었습니다.

- **QUIC의 주요 특징에 대해 설명해 주세요.**

  - QUIC 는 HTTP/2 + TLS + UDP 의 기능들을 포함하고 있습니다. QUIC는 네트워크 전송 문제를 아래와 같이 해결했습니다.

    1. 빠른 핸드셰이크와 커넥션 수립
       QUIC 는 UDP를 사용해서, TCP의 3-way 핸드셰이크에 비해 1-RTT 를 줄였습니다. TLS 1.3 을 사용해서 클라이언트가 TLS 핸드셰이크가 끝나기 전에 어플리케이션 데이터를 전송할 수 있게 하였습니다. QUIC 를 사용하면, 첫번째 핸드셰이크는 1RTT가 걸리고, 이미 연결되었던 클라이언트는 캐시된 정보를 사용하여 0-1 RTT 만 걸려서 TLS 연결을 할 수 있습니다.
    2. 암호화된 패킷
       전통적인 TCP 헤더는 암호화되거나 인증되지 않았습니다. 반면, QUIC 패킷들은 보안이 강화되었습니다. QUIC 패킷 헤더와 메세지 바디는 암호화되었습니다.
    3. HOL 블로킹을 피하기 위한 멀티플렉싱 업그레이드
       QUIC 에서는 한개의 연결에 다수의 스트림을 사용하여 멀티플렉싱을 했습니다. HTTP/2 도 멀티플렉싱을 지원했지만, QUIC는 스트림마다 독립되어 있어서 하나의 스트림에 있는 패킷이 손실되어도 다른 스트림에 영향을 주지 않습니다.
    4. 커넥션 마이그레이션
       기존의 TCP 연결은 (소스IP, 소스port, 목적지IP, 목적지port) 4개 중 1지만 바뀌어도 연결을 다시 해야 했습니다. 이것은 모바일 연결이 많아지는 지금 적합하지 않은 방식입니다. 기기들이 이동을 하면 IP 주소가 쉽게 바뀌기 때문입니다. 따라서 QUIC는 64-bit의 커넥션ID 를 바탕으로 연결합니다. 커넥션ID가 바뀌지 않는 이상 연결이 끊기지 않습니다.

    <details>
    <summary>QUIC Principle</summary>

    ![image](https://github.com/ddoddii/ddoddii.github.io/assets/95014836/e2582819-c606-43ce-b416-26e5d5d951a6)

    ![image](https://github.com/ddoddii/ddoddii.github.io/assets/95014836/f999a659-9ccf-47b6-94f0-a543d19c8a17)

    ![image](https://github.com/ddoddii/ddoddii.github.io/assets/95014836/ff94dc16-4f80-474e-88c6-1bd5e3be3e99)

    ![image](https://github.com/ddoddii/ddoddii.github.io/assets/95014836/f3f3edf8-da03-412b-8d5a-bd5d75794e5b)

    출처 : [What is QUIC? How Does It Boost HTTP/3?](https://www.cdnetworks.com/media-delivery-blog/what-is-quic/)

    </details>

### **7. TCP와 UDP의 차이에 대해 설명해 주세요.**

- **Checksum이 무엇인가요?**
  - TCP 와 UDP의 헤더에 있는 필드로, 오류 유무를 검사하기 위한 것입니다.
- **TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?**
  - TCP와 UDP모두 체크섬을 수행합니다. TCP의 경우 헤더와 데이터 부분 모두에 대한 체크섬 계산을 수행하여 데이터 손상 여부를 검사합니다. UDP도 마찬가지로 헤더와 데이터에 대한 체크섬을 계산하지만, 선택적이고 생략할 수 있습니다.
- **그렇다면, Checksum을 통해 오류를 정정할 수 있나요?**
  - 체크섬은 데이터가 전송 과정에서 손상되었는지 확인하는 오류 검출을 할 수 있습니다. 하지만 오류 정정은 다른 개념으로, 체크섬만으로 오류를 수정할 수는 없습니다.
- **TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.**
  - TCP 헤더에는 여러 가지 제어 정보가 포함되어 있습니다. 첫번째로, TCP 헤더의 시퀀스 번호는 해당 데이터가 송신 데이터의 몇번째 바이트에 해당하는지를 나타내어, 데이터의 순서를 보장합니다. 두번째로, TCP 헤더의 체크섬 필드는 데이터의 무결성을 검사합니다. 세번째로, 수신자가 정상적으로 받은 패킷에 대해 ACK 번호를 보냄으로써 수신자가 패킷을 제대로 받았는지 확인합니다. 만약 일정 시간 동안 ACK 를 받지 못하면, 해당 패킷을 재전송합니다.
- **TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요. ⭐️**
  - TCP가 혼잡 제어를 하는 알고리즘에는 Slow Start, Congestion Avoidance, Fast Recovery, Fast Retransmit 을 사용합니다. Slow Start 알고리즘에서는 초기 송신 측의 윈도우 크기를 1로 초기화하고, ACK 패킷을 받을 때마다 윈도우 크기를 지수적으로 증가시킵니다. Timeout 에 의해 패킷이 손실되거나, 3개의 중복 ACK가 오면 윈도우 크기를 절반으로 줄이는 방식을 채택합니다.
- **왜 HTTP는 TCP를 사용하나요?**
  - HTTP가 TCP를 사용하는 주된 이유는 TCP가 제공하는 신뢰성 있는 연결 지향적 특징 때문입니다. HTTP는 웹 페이지, 이미지, 비디오 등과 같은 웹 자원을 클라이언트와 서버 간에 전송하기 위해 설계된 프로토콜입니다. 이러한 데이터 전송이 정확하고 신뢰성 있게 이루어지도록 하기 위해 TCP의 여러 기능을 활용합니다:
- **Websocket 은 TCP/UDP 중 어떤 방식을 사용하고, 그 이유는 무엇일까요?**
  - Websocket 도 TCP를 사용합니다. 웹소켓도 최초 접속시 HTTP 에서 3-way handshake 과정을 거치고, HTTP upgrade 헤더를 이용해서 웹소켓 프로토콜로 전환시킵니다. 
- **그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?**
  - HTTP/3 에서는 QUIC 프로토콜을 사용하는데, QUIC 는 UDP기반입니다. 그렇지만 QUIC는 TCP의 주요 기능들을 제공합니다.
- **그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?**
  - 사용하는 프로토콜의 표준과 어플리케이션 계층의 프로토콜을 보고 판단합니다. 특성 서비스는 특정 프로토콜을 사용하도록 명시되어 있습니다. 예를 들어, 웹페에이지를 요청할 때 사용되는 HTTP/HTTPS 는 TCP 위에서 동작합니다. 두번째로, 브라우저는 URL상에 명시된 스키마(http,https,ws,wss)등을 통해 어떤 프로토콜을 사용해야 하는지 알 수 있습니다. 
- **본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?**
  - 프로토콜을 선택할 때는 여러 가지를 고려해야 합니다. 우선, 신뢰성을 기준으로 한다면 TCP의 데이터 순서 보장 기능, 에러 복구 기능 때문에 TCP 를 선택하겠습니다. 만약 퍼포먼스와 오버헤드를 줄이는 것을 기준으로 한다면 UDP를 선택하겠습니다. 
- **UDP를 사용하면 신뢰성을 보장하지 못하는 이유가 무엇일까요? ⭐️**
  - UDP는 애초에 최소한의 오버헤드로 데이터를 빠르게 전송하는데 초점을 두고 있습니다. 따라서 비연결형 프로토콜이고, 패킷이 제대로 도착했는지 확인하지도 않습니다. 

### **8. DHCP가 무엇인지 설명해 주세요.**

- **DHCP는 몇 계층 프로토콜인가요?**
- **DHCP는 어떻게 동작하나요?**
- **DHCP에서 UDP를 사용하는 이유가 무엇인가요?**
- **DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?**
- **DHCP의 유효기간은 얼마나 긴가요?**

### **9. IP 주소는 무엇이며, 어떤 기능을 하고 있나요?**

- **IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?**
- **IPv4와 IPv6의 차이에 대해 설명해 주세요.**
- **수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?**
- **IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?**
- **IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?**
- **IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?**
- **TTL(Hop Limit)이란 무엇인가요?**
- **IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.**

### **10. OSI 7계층에 대해 설명해 주세요.**

- **Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.**
- **L3 Switch와 Router의 차이에 대해 설명해 주세요.**
- **각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.**
- **각각의 Header의 Packing Order에 대해 설명해 주세요.**
- **ARP에 대해 설명해 주세요.**

### **11. 3-Way Handshake에 대해 설명해 주세요.**

- **ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?**
- **2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.**
- **두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?**
- **SYN Flooding 에 대해 설명해 주세요.**
- **위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?**

### **12. 4-Way Handshake에 대해 설명해 주세요.**

- **패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?**
- **빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?**
- **4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?**
- **왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?**

### **13. www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.**

- **DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?**
- **Web Server와 Web Application Server의 차이에 대해 설명해 주세요.**
- **URL, URI, URN은 어떤 차이가 있나요?**

  - URI는 Uniform Resource Identifier로, 통합 자원 식별자입니다. 즉, 인터넷 상의 리소스 자원 자체를 식별하는 고유한 문자열 시퀀스입니다. URL은 Uniform Resource Locator로, 네트워크 상에서 통합 자원(리소스)의 위치를 나타냅니다. URN은 Uniform Resource Name 으로, 자원의 이름입니다.

- **URL의 구성요소는 무엇인가요?**
  - URL은 리소스에 접근하기 위해 사용되는 프로토콜, 서버의 인터넷 주소, 웹 서버의 리소스로 구성되어 있습니다.

### **14. DNS에 대해 설명해 주세요.**

DNS는 호스트와 네임 서버가 이름을 번역하기 위해 소통하는 어플리케이션 계층 프로토콜입니다. DNS는 사람이 이해하는 호스트 명과 컴퓨터가 이해할 수 있는 IP주소 사이를 번역해주는 서비스를 제공합니다. 또한, DNS는 분산화되고 계층화된 데이터베이스 형태입니다.

- **DNS는 몇 계층 프로토콜인가요?**

  - DNS 는 어플리케이션 계층 프로토콜입니다. DNS는 메세지를 전달하기 위해 하위 전송 계층 프로토콜 (UDP or TCP) 를 사용하므로, 어플리케이션 계층 프로토콜입니다.

- **UDP와 TCP 중 어떤 것을 사용하나요?**

  - DNS는 몇 가지 케이스를 제외하고는 일반적으로 UDP 를 사용합니다. 가장 중요한 이유는, UDP 는 TCP 와 달리 연결 설정을 할 필요가 없이 바로 데이터를 전송하므로, 속도가 빠릅니다. 또 UDP 는 512 바이트를 넘어가지 않는 패킷만 전송이 가능한데, DNS가 다루는 데이터의 사이즈가 작으므로 적합합니다. 그래서 속도가 빠른 UDP 를 우선으로 선택합니다.
  - 그렇지만 UDP 는 연결을 보장하지 않고 데이터를 전송하므로 데이터가 제대로 갔는지 확인하지 않습니다. 그래서 데이터가 손실 될 수 있습니다. 그런데도 UDP 를 쓰는 이유는, UDP 는 빠른 연결과 상태를 저장하지 않는 stateless 특성 덕분에 더 많은 클라이언트들에게 데이터를 전송해줄 수 있습니다. UDP 의 안전이 의심되면, 어플리케이션 계층에 보호 수단을 더할 수 있습니다.
  - DNS 가 UDP 를 사용해서 받을 수 있는 공격으로는 DNS Spoofing 공격이 있습니다. 보낸 쪽이 데이터가 잘 갔는지 확인하지 않으므로 중간에서 가로채서, 다른 URL 을 보내주는 것입니다. 이 URL 에 악성 코드가 심어져 있으면 유저는 당할 수 있습니다.
  - DNS 가 TCP 를 사용하는 경우는 다음의 경우들입니다.
    - Zone Transfer
    - 큰 DNS 응답 : UDP 는 512 byte 이하의 데이터만 전송합니다. 그래서 큰 response 는 TCP 를 사용해야 합니다.
    - DNS over TCP and DNS over TLS : 보안을 위해, TCP 기반 프로토콜을 이용해 암호화할 수 있습니다.
    - 방화벽과 네트워크 제한 : 방화벽이나 네트워크가 UDP 를 제한하면, TCP 를 사용합니다.

- **DNS Recursive Query, Iterative Query가 무엇인가요?**

  - Recursive Query : 로컬 DNS 서버 -> root DNS 서버 -> TLD DNS 서버 -> authoritative DNS 서버 에게 차례대로 쿼리를 하는 것이다.

  - Iterative Query : 로컬 DNS 서버가 계속해서 순차적으로 root DNS 서버, TLD DNS 서버, authoritative DNS 서버 에게 물어보는 것이다.

- **DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?**

  - DNS가 UDP를 사용해서 쿼리에 손실이 발생하면 놀랍게도 어쩔 수 없습니다. 잃어버린 데이터는 그냥 잃어버린 것입니다. 그저 DNS 쿼리에 손실이 발생해서 생길 문제를 최소화하는 것이 최선입니다. DNS 서버를 여러 대를 쓰거나, 아예 호스트네임 말고 IP 주소를 쓰는 것이 대안이 될 수 있습니다.

- **캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?**

  - 캐싱된 DNS 쿼리가 잘못되었다면 가장 간단한 해결책은 해당 장치의 DNS 캐시를 클리어하는 것입니다. 예를 들어 mac 에서 `sudo killall -HUP mDNSResponser` 명령어를 사용하면 DNS 캐시를 클리어할 수 있습니다.

- **DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.**

  - Resource Records(RR) 는 hostname - IP address 를 매핑해주는 데이터셋입니다. DNS reply 메세지는 하나 이상의 RR을 담고 있습니다. RR는 4개 영역을 담고 있는 튜플입니다. (Name, Value, Type, TTL)
  - 여기서 Name, Value 의 의미는 Type 에 따라 달라집니다다.
    - A : name - hostname, value - IPV4 address ( www.naver.com , 223.130.195.200)
    - CNAME : name - alias name, value - canonical name ( www.ibm.com, servereast.backup2.ibm.com)
    - AAAA : name - hostname, value - IPV6 address

- **hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?**
  - 호스트 파일은 각각의 도메인네임과 이들의 IP주소를 하나하나 대응시켜서 저장해 놓은 텍스트파일입니다. 우리가 브라우저에 검색을 하면, 우선 호스트 파일을 먼저 검색합니다. 그 후 호스트 파일에 해당 IP 주소가 없으면 DNS서버에 쿼리를 날립니다. 따라서 DNS서버 쿼리보다는 호스트파일의 우선순위가 높습니다.

### **15. SOP 정책에 대해 설명해 주세요.**

- **CORS 정책이 무엇인가요?**
- **Preflight에 대해 설명해 주세요.**

### **16. Stateless와 Connectionless에 대해 설명해 주세요.**

- **왜 HTTP는 Stateless 구조를 채택하고 있을까요?**
- **Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?**
- **TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?**
- **HTTP/1.1 에서 keep-alive 옵션을 사용할 때 주의할 점은 무엇인가요?**
  - 서버에 여러 개의 클라이언트가 keep-alive 옵션을 사용하여 연결하면 서버 입장에서 커넥션을 유지하는데 큰 비용이 부담됩니다. 따라서 정말 연결 속도가 중요한 커넥션이 아닌 이상, 서버가 다운되지 않게끔 서버에서 keep-alive 옵션을 받을지 미리 설계하는 것이 중요합니다.

### **17. 라우터 내의 포워딩 과정에 대해 설명해 주세요.**

- **라우팅과 포워딩의 차이는 무엇인가요?**
- **라우팅 알고리즘에 대해 설명해 주세요.**
- **포워딩 테이블의 구조에 대해 설명해 주세요.**

### **18. 로드밸런서가 무엇인가요?**

- **L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.**
- **로드밸런서 알고리즘에 대해 설명해 주세요.**
- **로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?**
- **로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.**

### **19. 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.**

- **NAT에 대해 설명해 주세요.**
- **서브넷 마스크의 표현 방식에 대해 설명해 주세요.**
- **그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?**

### **20. 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.**

- **디멀티플렉싱의 과정에 대해 설명해 주세요.**

### **21. XSS에 대해서 설명해 주세요.**

- **CSRF랑 XSS는 어떤 차이가 있나요?**
- **XSS는 프론트엔드에서만 막을 수 있나요?**

### **22. HTTPS 는 HTTP 와 어떻게 다른가요?**

HTTP(Hypertext Transfer Protocol)는 클라이언트와 서버 간 통신을 위한 통신 규칙 세트 또는 프로토콜입니다. 사용자가 웹 사이트를 방문하면 사용자 브라우저가 웹 서버에 HTTP 요청을 전송하고 웹 서버는 HTTP 응답으로 응답합니다. 웹 서버와 사용자 브라우저는 데이터를 일반 텍스트로 교환합니다. 간단히 말해 HTTP 프로토콜은 네트워크 통신을 작동하게 하는 기본 기술입니다.

이름에서 알 수 있듯이 HTTPS(Hypertext Transfer Protocol Secure)는 HTTP의 확장 버전 또는 더 안전한 버전입니다. HTTPS에서는 브라우저와 서버가 데이터를 전송하기 전에 안전하고 암호화된 연결을 설정합니다.

- **HTTP 프로토콜은 어떻게 작동하나요?**
  - HTTP는 OSI(Open Systems Interconnection) 네트워크 통신 모델의 애플리케이션 계층 프로토콜입니다. HTTP는 여러 유형의 요청과 응답을 정의합니다. 예를 들어, 웹 사이트의 일부 데이터를 보려는 경우 *HTTP GET* 요청을 전송합니다. 연락처 양식 작성과 같은 일부 정보를 전송하려는 경우 *HTTP PUT* 요청을 전송합니다.
- **HTTPS 프로토콜은 어떻게 작동하나요?**
  - HTTPS는 HTTP 요청 및 응답을 SSL 및 TLS 기술에 결합합니다.
  - SSL 인증서는 사용자가 사이트에 제공하는 정보를 암호화하는데, 쉽게 말해서 데이터를 암호로 바꾼다고 생각하면 쉽습니다. 이렇게 전송된 데이터는 중간에서 누군가 훔쳐 낸다고 하더라도 데이터가 암호화되어있기 때문에 해독할 수 없습니다. 그 외에도 HTTPS는 TLS(전송 계층 보안) 프로토콜을 통해서도 보안을 유지합니다.
- **TLS 기술은 무엇인가요?**
  - Transport Layer Security. 대칭키를 사용해서 암호화한다.

### **23. REST API 는 무엇인가요?**

REST API 란 Resource 를 Representation 형태로 변환해서 주고 받기 위해 HTTP 스펙을 어떻게 잘 주고받을 지 설명한 개념입니다. REST 아키텍쳐는 로이 필딩의 논문에서 제안한 개념으로, HTTP를 사용해 잘 통신하기 위한 방법론이라고 할 수 있습니다.

- **Representation 이란 무엇인가요?**

  - 어떤 리소스의 특정 시점 상태를 반영하고 있는 정보입니다. 하나의 Representation 은 representation data 와 representation metadata 로 구성됩니다. 예를 들어, HTTP `GET` 요청을 보내서 아래와 같은 response 를 받았을때, "hello" 가 representation data 이고, "Content-Type: text/plain", "Content-Language: en" 등이 representation metadata 입니다.

    ```text
    HTTP/1.1 200 OK
    Content-Length: 6
    Date: Sun, 19 Mar 2017 10:20:47 GMT
    Last-Modified: Sun, 19 Mar 2017 08:00:00 GMT
    Content-Type: text/plain
    Content-Language: en

    hello
    ```

- **Resource란 무엇인가요?**

  - 리소스란 HTTP의 요청 대상입니다.

- **REST 아키텍쳐는 무엇인가요?**

  - REST 란 REpresentation State Transfer 의 줄임말입니다. "State"는 어플리케이션의 상태를 의미하며, "Transfer"는 이 상태의 전송을 의미합니다.

  - REST 는 아래 6가지 사항을 제안합니다.
    1. Client-Server : 클라이언트와 서버 어플리케이션은 완전히 독립적이어야 합니다.
    2. Stateless : 각 요청에서 이의 처리에 필요한 모든 정보를 포함해야 합니다. 서버 어플리케이션은 클라이언트 요청과 관련된 데이터를 저장할 수 없습니다.
    3. Cache : 리소스를 클라이언트 또는 서버 측에서 캐싱할 수 있어야 합니다. 또한 서버 응답에는 전달된 리소스에 대해 캐싱이 허용되는지 여부에 대한 정보도 포함되어야 합니다.
    4. Uniform Interface : 요청이 어디서 오는지와 무관하게, 동일한 리소스에 대한 모든 API 요청은 동일하게 보여야 합니다. REST API는 사용자의 이름이나 이메일 주소 등의 동일한 데이터 조각이 오직 하나의 URI에 속함을 보장해야 합니다.
    5. Layered System : 계층으로 구성되어야 하며, 각 레이어에 속한 구성요소는 인접하지 않은 레이어의 구성요소를 볼 수 없어야 합니다.
    6. Code-On-Demand(옵션) : REST API는 일반적으로 정적 리소스를 전송하지만, 특정한 경우에는 응답에 실행 코드(예: Java 애플릿)를 포함할 수도 있습니다. 이 프로그램을 클라이언트가 실행할 수 있어야 합니다.

### **24. 토큰 기반 인증 과 쿠키 / 세션 이용한 인증의 차이는 무엇인가요?**

### **25. OpenAI API 를 stream 방식으로 사용한다면, 서버와 클라이언트는 어떤 프로토콜을 사용하여 통신하는 것이 좋을까요?⭐️**

stream 방식을 사용하면, 서버는 한번 요청을 보냈을 때 연속적인 응답을 받게 됩니다. 이것을 실시간으로 클라이언트에게 전달해주기 위해서는 우선적으로 websocket 방식을 선택할 것 같습니다. Websocket은 클라이언트와 서버 사이에 양방향 통신 채널을 제공합니다. websocket 은 HTTP 연결을 업그레이드하여 클라이언트 또는 서버가 연결을 끊지 않는 이상 연결이 지속됩니다. 이를 통해 서버와 클라이언트가 실시간으로 데이터를 교환할 수 있습니다.

두번째로는 HTTP/2 프로토콜을 선택할 것 같습니다. HTTP/2 는 HTTP/1.1 과 달리 여러 파일을 한번에 병렬로 전송합니다. 또한 HTTP/2 에서는 하나의 커넥션에 여러 개의 스트림이 동시에 요청, 응답 합니다. HTTP/2 부터는 stream 을 통해 요청과 응답이 묶일 수 있어 다수의 요청을 병렬적으로 처리가 가능합니다.

- **서버 - 클라이언트가 소통하는 프로토콜에는 어떤 방법이 있나요 ? HTTP 방식 말고 다른 방식도 설명해보세요.**

  - 우선, 프로토콜이란 단순히 서버와 클라이언트가 소통하는 방식에 대한 약속입니다. HTTP 말고도 다양한 형태가 있습니다.
  - WebSocket
    - 실시간, 양방향 통신을 위한 프로토콜으로, HTTP 을 업그레이드한 연결 형태입니다.
  - TCP/IP , UDP
    - 직접 네트워크 레벨에서 TCP/IP 또는 UDP 를 사용할 수 있습니다. 이때 어플리케이션 개발자는 추가적인 프로토콜 레이어나 핸드쉐이킹, 데이터 전송 방식을 직접 관리해야 합니다.

- **그렇다면 마이크로서비스 형태에서 서로 다른 서버끼리 소통하는 상황을 봅시다. 이때는 서버끼리 어떠한 형태의 프로토콜을 사용해서 소통하는 것이 좋을까요?**

  - 서버끼리의 소통에는 **gRPC** 가 좋은 방법입니다. gRPC는 Google 에서 만든 RPC(Remote Procedure Call) 프로토콜입니다. 우선 gRPC는 서버-클라이언트 프로토콜이 아니라 서버끼리의 소통을 목적으로 만들어졌습니다. (웹 브라우저가 기본적으로는 gRPC 를 지원하지 않습니다.)
  - 첫번쨰로, gRPC 는 매우 간편하고, 확장성이 뛰어납니다. 각각 언어마다 HTTP 라이브러리가 있습니다. (예를 들어 파이썬은 HTTP 1.1 을 사용하는 `requests` 가 있고, Golang 은 HTTP 2.0 을 기본으로 하는 `http` 라이브러리가 있습니다.) 만약 마이크로서비스마다 다른 언어의 어플리케이션을 활용한다면, 이것들을 관리하는 것은 복잡합니다. gRPC 는 우리를 대신해서 HTTP 2.0 연결을 구현해줍니다. 또한, gRPC는 protocol buffer 를 사용해서 각 언어에 맞는 코드를 생성해줍니다. protocol buffer 는 소통을 위한 일종의 계약서입니다. 어떤 형태, 어떤 데이터를 주고 받을 지 사전에 정의합니다. protofile 에 정의를 하면, 각각 사용하는 언어를 바탕으로 코드를 생성합니다.
  - 두번째로는 성능입니다. gRPC 는 HTTP/2 를 기반으로 작동합니다. 또한, protocol buffer 는 바이너리 형태로 직렬화되고, 전송됩니다. 이것은 전통적인 json 을 전송하는 방식보다 훨씬 빠릅니다.

- **만약 클라이언트에서 10초가 지나면 무조건 timeout 이 된다면, 서버가 API 에 요청을 보내 10초 이상 기다린 후 response 받은 것을 어떤 방식으로 클라이언트에게 알려줄 수 있을까요? 프로토콜을 설계해도 됩니다.**
  - 우선 타임아웃이 Read Timeout 이라고 가정합시다. Read Timeout 은 클라이언트와 서버가 연결에는 성공했지만, 클라이언트가 원하는 요청에 대해 서버가 너무 오랫동안 응답을 못해 클라이언트가 연결을 해제하는 것입니다. 즉, 클라이언트에서 요청을 보낸 후 10초가 지나도 응답이 오지 않을때, 타임아웃이 발생하는 상황입니다.
  - 이때 생각해볼 수 있는 것은 비동기 응답 메커니즘입니다. 클라이언트가 요청을 보낼 때 서버는 요청을 비동기적으로 처리하고, 클라이언트는 응답을 기다리는 대신 즉시 반환된 요청 식별자를 사용하여 나중에 결과를 조회할 수 있습니다. 클라이언트는 반환된 요청 식별자를 사용하여 서버에 요청 상태를 주기적으로 조회합니다. 서버에서 요청 처리가 완료되면, 클라이언트가 조회 요청을 통해 상태를 확인할 때 결과를 전달하거나, 결과가 준비되었음을 알려주는 다른 메커니즘 (ex. Server Sent Event) 를 사용하여 클라이언트에게 알려줄 수 있습니다.
  - 이때 클라이언트가 계속 조회하는 방식은 폴링 또는 롱폴링 방식이 있습니다. 폴링 방식은 클라이언트가 일정한 주기로 서버에게 HTTP 요청을 보내는 방식입니다. 하지만 응답이 언제 올지 예측하기 어려우므로, 불필요한 HTTP 오버헤드가 발생합니다. 롱폴링 방식은 클라이언트가 HTTP 요청시 해당 요청을 일정 시간 동안 대기시킵니다. 만약 , 대기 시간 안에 데이터가 업데이트 되었다면, 그 순간 응답을 전달하고 연결을 종료합니다.
  - 반대로 서버 쪽에서 클라이언트에게 데이터가 준비되었음을 알려주는 메커니즘이 있습니다. Server-sent Events 를 사용하면 서버 -> 클라이언트 단방향으로 서버의 이벤트가 완료되었을 때 클라이언트로 메세지를 푸쉬할 수 있습니다.

### 26. 127.0.0.1 은 특별한 IP 주소입니다. 이 IP 주소의 의미는 무엇인가요?

127.0.0.1 은 루프백 혹은 로컬호스트 주소입니다. 호스트 A 가 호스트 b에게 패킷을 전달하고 싶을 때, 패킷에는 목적지인 B의 IP 주소가 담기게 됩니다. 만약 목적지 IP 주소를 127.0.0.1 로 설정하면, A의 네트워크 계층은 이 패킷을 외부로 전송하지 않고, 본인이 받은 것 처럼 처리합니다.

- **로컬호스트 주소는 어떤 용도로 사용되나요?**
  - 로컬호스트의 개념은 웹 개발과 테스트에 중요합니다. 로컬 서버를 사용하여 개발자들은 웹사이트나 어플리케이션을 실행함으로써, 모든 것이 올바르게 작동하는지 테스트할 수 있습니다. 또한 127.0.0.1 로 보내진 요청은 인터넷을 통과하지 않고 직접 컴퓨터 내에서 처리되기 때문에 오프라인 환경에서도 사용할 수 있습니다.

### 27. form-data 와 x-www-form-urlencoded 의 차이는 무엇인가요?

### 28. 캐릭터 인코딩에는 어떤 방식들이 있나요?

- ASCII : 아스키는 7bit 인코딩으로 총 1byte(8bit)에서 7bit를 사용하여 128개의 문자를 표현할 수 있다. (0 ~ 127)나머지 1bit는 에러 검출을 위한 Parity bit로 비워두어 총 1byte로 문자를 표현한다.
- ANSI : 기존 아스키 코드의 7bit가 아닌 8bit를 문자를 표현하는데 사용하여 총 256개의 문자를 표현할 수 있게 되었다. (128 ~ 255)
- 멀티바이트 인코딩(Multibyte Encoding) : 한국어, 중국어, 일본어는 문자의 수가 매우 많기 때문에 확장아스키코드 영역의 128개로도 부족했기 때문이었다.따라서 1byte가 아닌 여러 byte를 통해 문자를 표현한 것이 멀티바이트 인코딩이다.
- 유니코드 : 현존하는 문자 인코딩 방법들을 모두 유니코드로 교체
