### Computer Network

<details>
<summary>📚 공부한 자료</summary>

- 네트워크 하향식 접근
- HTTP 완벽 가이드
- 성공과 실패를 결정하는 1%의 네트워크 원리

</details>

### 1. 쿠키와 세션의 차이에 대해 설명해 주세요.

**쿠키**는 클라이언트 측에서 사용자의 브라우저에 저장되는 작은 데이터 조각입니다. 쿠키는 클라이언트의 인증을 도와줍니다. 클라이언트 로컬에 저장하기 때문에 변질되거나 노출될 위험이 있습니다. 반면, **세션**은 서버 쪽에서 사용자의 정보를 저장합니다. 쿠키를 사용하지만, 쿠키에 세션ID를 저장하여 클라이언트에게 보냅니다. 세션을 서버에서 관리하기 때문에 비교적 보안성이 높습니다.

- **세션 방식의 로그인 과정에 대해 설명해 주세요.**
- 1. **로그인 요청:** 사용자가 로그인 정보(예: 사용자명과 비밀번호)를 입력하여 서버에 전송합니다.
  1. **인증:** 서버는 제공된 로그인 정보를 검증합니다.
  1. **세션 생성:** 인증이 성공하면, 서버는 해당 사용자에 대한 세션을 생성하고, 고유한 세션 ID를 발급합니다.
  1. **세션 ID 저장:** 발급된 세션 ID는 쿠키에 저장되어 클라이언트(브라우저)로 전송됩니다.
  1. **세션 사용:** 사용자가 이후 요청을 할 때마다 브라우저는 세션 ID가 포함된 쿠키를 서버에 전송합니다. 서버는 이 세션 ID를 통해 사용자를 식별하고, 상태 정보를 유지합니다.

- **HTTP의 특성인 Stateless에 대해 설명해 주세요.**
  - HTTP 프로토콜은 **Stateless**로 설계되었습니다. 이는 각 요청이 독립적이며 서로 연결되어 있지 않다는 것을 의미합니다. 서버는 클라이언트의 이전 상태나 요청 정보를 기억하지 않습니다. 이로 인해 웹은 기본적으로 사용자의 상태 정보를 유지하지 않는 환경입니다.
- **Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?**

  - Stateless 는 구현이 단순하고, 서버의 확장성이 좋아지고, 각 요청과 응답이 독립적이므로 응답을 캐시에 저장하고 재사용하는 것이 가능하다는 여러 장점이 있습니다. 그러나, 이전 요청과 이후 상태 사이에 상태를 유지하지 않기 때문에 사용자의 로그인 등 상태를 유지해야 할 때를 위해 세션과 쿠키를 구현한 것입니다.

- **Stateless의 경우 왜 확정성이 좋다고 할까요?**

  - Stateful 한 경우에는 클라이언트가 서버에 접속하면 특정 서버와 계속 연결 상태에 있어야 하는데 이 부분을 관리하기 힘듭니다. 반면 Stateless 한 경우 클라이언트는 서버와 아무런 연결 고리가 없기 때문에 요청을 보낼 때마다 아무 서버나 서비스할 수 있는 구조기 때문에 웹서버를 확장한다고 했을 때 고려할 사항이 줄어듭니다.

- **규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?**

  - 로드 밸런싱으로 인한 분산 처리에서는 세션 저장소가 일치하지 않아서 세션 불일치 문제가 발생할 수 있습니다. 이를 해결하기 위한 방법은 크게 3가지가 있습니다.
    1. Sticky Session
       클라이언트의 요청을 하나의 서버로 고정시키는 방식입니다. 하지만 특정 서버에 장애가 발생하면 해당 서버로 요청을 보내는 모든 사용자들의 세션 정보를 잃게 되는 단점이 있습니다. 또한, 사용자들이 하나의 서버로 몰리게 되면 과부하가 발생할 수 있습니다.
    2. Session Clustering
       클러스터링은 여러 대의 서버들이 연결되어 하나의 시스템처럼 동작하는 것을 의미합니다. 대표적으로 Tomcat 은 클러스터링을 위해 all-to-all 세션 복제 방식을 사용합니다. 사용자의 세션이 업데이트 될 때마다 Tomcat의 DeltaManager가 다른 모든 서버에 해당 세션의 정보를 복제 합니다. 하지만 서버의 수가 늘어날 수록 많은 메모리가 필요하고, 세션이 복제되는 와중에는 세션 불일치 문제가 생길 수 있습니다.
    3. Session Storage
       각각의 서버에 세션 정보를 저장하는 것이 아니라 외부에 저장소를 만들고 이 서버에 모든 데이터를 저장하는 방법입니다. Redis 같은 In-memory(인메모리) 데이터 저장소를 사용함으로써 빠르게 세션을 조회할 수 있습니다.

- **토큰 기반 방식은 어떤 장점이 있을까요?**

### 2. HTTP 응답코드에 대해 설명해 주세요.

- **401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?**
- **200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.**
- **필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.**

### 3. HTTP Method 에 대해 설명해 주세요.

- **HTTP Method의 멱등성에 대해 설명해 주세요.**
- **GET과 POST의 차이는 무엇인가요?**
- **POST와 PUT, PATCH의 차이는 무엇인가요?**
- **HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?**

### **4. HTTP에 대해 설명해 주세요.**

- **공개키와 대칭키에 대해 설명해 주세요.**
- **왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?**
- **SSL과 TLS의 차이는 무엇인가요?**

### **5. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.**

- **소켓과 포트의 차이가 무엇인가요?**
- **여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?**
- **사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?**

### **6. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?**

HTTP/2 가 HTTP/1.1 에 비해 훨씬 빠르고 효율적인데, 크게 4가지 이유가 있습니다. 첫번째로는 **우선순위 지정**입니다. 웹에서 우선순위는 컨텐츠가 로드되는 순서를 나타냅니다. HTTP/2 에서 개발자는 우선순위 지정을 직접 세부적으로 제어하여, 사용자가 인지하는 페이지 로드 속도를 최대화할 수 있습니다.

두번째로는 **멀티플렉싱**입니다. HTTP/1.1은 리소스를 차례로 로드하므로 한 리소스를 로드할 수 없는 경우 그 뒤에 있는 다른 모든 리소스가 차단됩니다. HTTP/2 는 물리적으로 단일 TCP 연결을 사용하여 한번에 여러 개 논리적 데이터 스트림을 보낼 수 있어서, 한 리소스 때문에 다른 리소스가 차단되지 않습니다.

세번째는 **서버 푸쉬** 입니다. HTTP/2는 클라이언트가 요청하기 전에 서버가 클라이언트에 콘텐츠를 "푸시"할 수 있습니다.

네번째는 **헤더 압축**과 **바이너리 프레이밍** 입니다. HTTP/2는 HTTP 헤더 패킷에서 중복 정보를 제거하는 HPACK이라는 고급 압축 방법을 사용하여 HTTP 패킷을 더 작게 만들었습니다. 또한, 원래 HTTP/1.1 에서는 요청,응답 메세지를 텍스트 형식으로 전달했었는데, HTTP/2.0 에서는 프레임 단위로 나누어지고 바이너리 형식으로 인코딩해서 파싱,전송 속도가 더 빨라졌습니다.

- **HTTP의 HOL Blocking 에 대해 설명해 주세요.**

  - HTTP/1.0 에서는 매 요청마다 연결/해제의 과정이 있었어서, 이로 인해 많은 오버헤드가 발생했습니다. 따라서 HTTP/1.1 에서는 이를 해결하기 위해 두 개의 연결방식이 추가되었습니다. 그것은 Persistent connection(지속적 연결) 모델과 더 발전한 HTTP pipelining 이었습니다.
  - Pipelining 방식에서는 클라이언트는 요청을 응답에 상관없이 보내고 서버는 응답을 요청이 들어온 순서대로 보내줍니다. 만약 클라이언트에서 1,2,3 번 요청을 보냈는데 각각 1번은 100초 2번은 20초 3번은 10초가 소요되는 요청이었을 때, 2,3번 요청은 이미 처리가 되었지만 1번을 먼저 응답 보내야 하므로 2,3번 응답은 계속 블로킹 됩니다. 이것이 HTTP/1.1의 HOL Blocking 입니다.

- **HTTP/2 에서는 HOL Blocking 이 발생하나요?**

  - HTTP/2 의 경우 요청은 하나의 연결에서 병렬적으로 보낼 수 있습니다. 따라서 1,2,3번 요청을 보내서 1번 요청이 처리하는 중이어도 2,3번 요청의 응답은 먼저 보내줄 수 있습니다.
  - 그러나 HTTP/2 는 TCP 를 사용합니다. TCP는 전송한 패킷이 손실되었으면 재전송을 합니다. 이때 패킷의 순서가 역전되지 않게 후속 패킷은 대기합니다. 따라서 TCP 수준에서의 HOL은 발생합니다.

- **HTTP/3.0의 주요 특징에 대해 설명해 주세요.**
  - HTTP/3 은 HTTP Over QUIC 입니다. QUIC는 UDP 위에서 구현되었고, 멀티플렉스와 보안을 지원하는 전송 레이어 프로토콜입니다. TCP를 사용하지 않기 때문에 TCP의 HOL 블로킹 문제가 생기지 않습니다. 따라서 최소한의 기능만 있는 UDP를 바탕으로 신뢰성을 보장해줄 수 있는 QUIC 프로토콜을 만들었습니다.

### **7. TCP와 UDP의 차이에 대해 설명해 주세요.**

- **Checksum이 무엇인가요?**
- **TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?**
- **그렇다면, Checksum을 통해 오류를 정정할 수 있나요?**
- **TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.**
- **TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.**
- **왜 HTTP는 TCP를 사용하나요?**
- **Websocket 은 TCP/UDP 중 어떤 방식을 사용하고, 그 이유는 무엇일까요?**
- **그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?**
- **그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?**
- **본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?**
- **UDP를 사용하면 신뢰성을 보장하지 못하는 이유가 무엇일까요?⭐️**

### **8. DHCP가 무엇인지 설명해 주세요.**

- **DHCP는 몇 계층 프로토콜인가요?**
- **DHCP는 어떻게 동작하나요?**
- **DHCP에서 UDP를 사용하는 이유가 무엇인가요?**
- **DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?**
- **DHCP의 유효기간은 얼마나 긴가요?**

### **9. IP 주소는 무엇이며, 어떤 기능을 하고 있나요?**

- **IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?**
- **IPv4와 IPv6의 차이에 대해 설명해 주세요.**
- **수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?**
- **IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?**
- **IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?**
- **IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?**
- **TTL(Hop Limit)이란 무엇인가요?**
- **IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.**

### **10. OSI 7계층에 대해 설명해 주세요.**

- **Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.**
- **L3 Switch와 Router의 차이에 대해 설명해 주세요.**
- **각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.**
- **각각의 Header의 Packing Order에 대해 설명해 주세요.**
- **ARP에 대해 설명해 주세요.**

### **11. 3-Way Handshake에 대해 설명해 주세요.**

- **ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?**
- **2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.**
- **두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?**
- **SYN Flooding 에 대해 설명해 주세요.**
- **위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?**

### **12. 4-Way Handshake에 대해 설명해 주세요.**

- **패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?**
- **빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?**
- **4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?**
- **왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?**

### **13. [www.github.com을](http://www.github.xn--com-of0o/) 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.**

- **DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?**
- **Web Server와 Web Application Server의 차이에 대해 설명해 주세요.**
- **URL, URI, URN은 어떤 차이가 있나요?**

### **14. DNS에 대해 설명해 주세요.**

DNS는 호스트와 네임 서버가 이름을 번역하기 위해 소통하는 어플리케이션 계층 프로토콜입니다. DNS는 사람이 이해하는 호스트 명과 컴퓨터가 이해할 수 있는 IP주소 사이를 번역해주는 서비스를 제공합니다. 또한, DNS는 분산화되고 계층화된 데이터베이스 형태입니다.

- **DNS는 몇 계층 프로토콜인가요?**
  - DNS 는 어플리케이션 계층 프로토콜입니다. DNS는 메세지를 전달하기 위해 하위 전송 계층 프로토콜 (UDP or TCP) 를 사용하므로, 어플리케이션 계층 프로토콜입니다.
- **UDP와 TCP 중 어떤 것을 사용하나요?**

  - DNS는 몇 가지 케이스를 제외하고는 일반적으로 UDP 를 사용합니다. 가장 중요한 이유는, UDP 는 TCP 와 달리 연결 설정을 할 필요가 없이 바로 데이터를 전송하므로, 속도가 빠릅니다. 또 UDP 는 512 바이트를 넘어가지 않는 패킷만 전송이 가능한데, DNS가 다루는 데이터의 사이즈가 작으므로 적합합니다. 그래서 속도가 빠른 UDP 를 우선으로 선택합니다.
  - 그렇지만 UDP 는 연결을 보장하지 않고 데이터를 전송하므로 데이터가 제대로 갔는지 확인하지 않습니다. 그래서 데이터가 손실 될 수 있습니다. 그런데도 UDP 를 쓰는 이유는, UDP 는 빠른 연결과 상태를 저장하지 않는 stateless 특성 덕분에 더 많은 클라이언트들에게 데이터를 전송해줄 수 있습니다. UDP 의 안전이 의심되면, 어플리케이션 계층에 보호 수단을 더할 수 있습니다.
  - DNS 가 UDP 를 사용해서 받을 수 있는 공격으로는 DNS Spoofing 공격이 있습니다. 보낸 쪽이 데이터가 잘 갔는지 확인하지 않으므로 중간에서 가로채서, 다른 URL 을 보내주는 것입니다. 이 URL 에 악성 코드가 심어져 있으면 유저는 당할 수 있습니다.
  - DNS 가 TCP 를 사용하는 경우는 다음의 경우들입니다.
    - Zone Transfer
    - 큰 DNS 응답 : UDP 는 512 byte 이하의 데이터만 전송합니다. 그래서 큰 response 는 TCP 를 사용해야 합니다.
    - DNS over TCP and DNS over TLS : 보안을 위해, TCP 기반 프로토콜을 이용해 암호화할 수 있습니다.
    - 방화벽과 네트워크 제한 : 방화벽이나 네트워크가 UDP 를 제한하면, TCP 를 사용합니다.

- **DNS Recursive Query, Iterative Query가 무엇인가요?**

  - Recursive Query : 로컬 DNS 서버 -> root DNS 서버 -> TLD DNS 서버 -> authoritative DNS 서버 에게 차례대로 쿼리를 하는 것이다.

  - Iterative Query : 로컬 DNS 서버가 계속해서 순차적으로 root DNS 서버, TLD DNS 서버, authoritative DNS 서버 에게 물어보는 것이다.

- **DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?**

  - DNS가 UDP를 사용해서 쿼리에 손실이 발생하면 놀랍게도 어쩔 수 없습니다. 잃어버린 데이터는 그냥 잃어버린 것입니다. 그저 DNS 쿼리에 손실이 발생해서 생길 문제를 최소화하는 것이 최선입니다. DNS 서버를 여러 대를 쓰거나, 아예 호스트네임 말고 IP 주소를 쓰는 것이 대안이 될 수 있습니다.

- **캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?**

  - 캐싱된 DNS 쿼리가 잘못되었다면 가장 간단한 해결책은 해당 장치의 DNS 캐시를 클리어하는 것입니다. 예를 들어 mac 에서 `sudo killall -HUP mDNSResponser` 명령어를 사용하면 DNS 캐시를 클리어할 수 있습니다.

- **DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.**

  - Resource Records(RR) 는 hostname - IP address 를 매핑해주는 데이터셋입니다. DNS reply 메세지는 하나 이상의 RR을 담고 있습니다. RR는 4개 영역을 담고 있는 튜플입니다. (Name, Value, Type, TTL)
  - 여기서 Name, Value 의 의미는 Type 에 따라 달라집니다다.
    - A : name - hostname, value - IPV4 address ( www.naver.com , 223.130.195.200)
    - CNAME : name - alias name, value - canonical name ( www.ibm.com, servereast.backup2.ibm.com)
    - AAAA : name - hostname, value - IPV6 address

- **hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?**
  - 호스트 파일은 각각의 도메인네임과 이들의 IP주소를 하나하나 대응시켜서 저장해 놓은 텍스트파일입니다. 우리가 브라우저에 검색을 하면, 우선 호스트 파일을 먼저 검색합니다. 그 후 호스트 파일에 해당 IP 주소가 없으면 DNS서버에 쿼리를 날립니다. 따라서 DNS서버 쿼리보다는 호스트파일의 우선순위가 높습니다.

### **15. SOP 정책에 대해 설명해 주세요.**

- **CORS 정책이 무엇인가요?**
- **Preflight에 대해 설명해 주세요.**

### **16. Stateless와 Connectionless에 대해 설명해 주세요.**

- **왜 HTTP는 Stateless 구조를 채택하고 있을까요?**
- **Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?**
- **TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?**

### **17. 라우터 내의 포워딩 과정에 대해 설명해 주세요.**

- **라우팅과 포워딩의 차이는 무엇인가요?**
- **라우팅 알고리즘에 대해 설명해 주세요.**
- **포워딩 테이블의 구조에 대해 설명해 주세요.**

### **18. 로드밸런서가 무엇인가요?**

- **L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.**
- **로드밸런서 알고리즘에 대해 설명해 주세요.**
- **로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?**
- **로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.**

### **19. 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.**

- **NAT에 대해 설명해 주세요.**
- **서브넷 마스크의 표현 방식에 대해 설명해 주세요.**
- **그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?**

### **20. 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.**

- **디멀티플렉싱의 과정에 대해 설명해 주세요.**

### **21. XSS에 대해서 설명해 주세요.**

- **CSRF랑 XSS는 어떤 차이가 있나요?**
- **XSS는 프론트엔드에서만 막을 수 있나요?**

### **22. HTTPS 는 HTTP 와 어떻게 다른가요?**

HTTP(Hypertext Transfer Protocol)는 클라이언트와 서버 간 통신을 위한 통신 규칙 세트 또는 프로토콜입니다. 사용자가 웹 사이트를 방문하면 사용자 브라우저가 웹 서버에 HTTP 요청을 전송하고 웹 서버는 HTTP 응답으로 응답합니다. 웹 서버와 사용자 브라우저는 데이터를 일반 텍스트로 교환합니다. 간단히 말해 HTTP 프로토콜은 네트워크 통신을 작동하게 하는 기본 기술입니다.

이름에서 알 수 있듯이 HTTPS(Hypertext Transfer Protocol Secure)는 HTTP의 확장 버전 또는 더 안전한 버전입니다. HTTPS에서는 브라우저와 서버가 데이터를 전송하기 전에 안전하고 암호화된 연결을 설정합니다.

- **HTTP 프로토콜은 어떻게 작동하나요?**
  - HTTP는 OSI(Open Systems Interconnection) 네트워크 통신 모델의 애플리케이션 계층 프로토콜입니다. HTTP는 여러 유형의 요청과 응답을 정의합니다. 예를 들어, 웹 사이트의 일부 데이터를 보려는 경우 *HTTP GET* 요청을 전송합니다. 연락처 양식 작성과 같은 일부 정보를 전송하려는 경우 *HTTP PUT* 요청을 전송합니다.
- **HTTPS 프로토콜은 어떻게 작동하나요?**
  - HTTPS는 HTTP 요청 및 응답을 SSL 및 TLS 기술에 결합합니다.
  - SSL 인증서는 사용자가 사이트에 제공하는 정보를 암호화하는데, 쉽게 말해서 데이터를 암호로 바꾼다고 생각하면 쉽습니다. 이렇게 전송된 데이터는 중간에서 누군가 훔쳐 낸다고 하더라도 데이터가 암호화되어있기 때문에 해독할 수 없습니다. 그 외에도 HTTPS는 TLS(전송 계층 보안) 프로토콜을 통해서도 보안을 유지합니다.
- **TLS 기술은 무엇인가요?**
  - Transport Layer Security. 대칭키를 사용해서 암호화한다.

### **23. REST API 는 무엇인가요?**

REST API 란 REST(REpresentational State Transfer) 아키텍쳐 스타일의 디자인 원칙을 준수하는 API 입니다.

- **REST 아키텍쳐는 무엇인가요?**
  - REST 는 아래 6가지 제한 사항을 만족해야 합니다.
    1. Client-Server : 클라이언트와 서버 어플리케이션은 완전히 독립적이어야 합니다.
    2. Stateless : 각 요청에서 이의 처리에 필요한 모든 정보를 포함해야 합니다. 서버 어플리케이션은 클라이언트 요청과 관련된 데이터를 저장할 수 없습니다.
    3. Cache : 리소스를 클라이언트 또는 서버 측에서 캐싱할 수 있어야 합니다. 또한 서버 응답에는 전달된 리소스에 대해 캐싱이 허용되는지 여부에 대한 정보도 포함되어야 합니다.
    4. Uniform Interface : 요청이 어디서 오는지와 무관하게, 동일한 리소스에 대한 모든 API 요청은 동일하게 보여야 합니다. REST API는 사용자의 이름이나 이메일 주소 등의 동일한 데이터 조각이 오직 하나의 URI에 속함을 보장해야 합니다.
    5. Layered System : 계층으로 구성되어야 하며, 각 레이어에 속한 구성요소는 인접하지 않은 레이어의 구성요소를 볼 수 없어야 합니다.
    6. Code-On-Demand(옵션) : REST API는 일반적으로 정적 리소스를 전송하지만, 특정한 경우에는 응답에 실행 코드(예: Java 애플릿)를 포함할 수도 있습니다. 이 프로그램을 클라이언트가 실행할 수 있어야 합니다.

### **24. 토큰 기반 인증 과 쿠키 / 세션 이용한 인증의 차이는 무엇인가요?**

### **25. OpenAI API 를 stream 방식으로 사용한다면, 서버와 클라이언트는 어떤 프로토콜을 사용하여 통신하는 것이 좋을까요?⭐️**

stream 방식을 사용하면, 서버는 한번 요청을 보냈을 때 연속적인 응답을 받게 됩니다. 이것을 실시간으로 클라이언트에게 전달해주기 위해서는 우선적으로 websocket 방식을 선택할 것 같습니다. Websocket은 클라이언트와 서버 사이에 양방향 통신 채널을 제공합니다. websocket 은 HTTP 연결을 업그레이드하여 클라이언트 또는 서버가 연결을 끊지 않는 이상 연결이 지속됩니다. 이를 통해 서버와 클라이언트가 실시간으로 데이터를 교환할 수 있습니다.

두번째로는 HTTP/2 프로토콜을 선택할 것 같습니다. HTTP/2 는 HTTP/1.1 과 달리 여러 파일을 한번에 병렬로 전송합니다. 또한 HTTP/2 에서는 하나의 커넥션에 여러 개의 스트림이 동시에 요청, 응답 합니다. HTTP/2 부터는 stream 을 통해 요청과 응답이 묶일 수 있어 다수의 요청을 병렬적으로 처리가 가능합니다.

- **서버 - 클라이언트가 소통하는 프로토콜에는 어떤 방법이 있나요 ? HTTP 방식 말고 다른 방식도 설명해보세요.**

  - 우선, 프로토콜이란 단순히 서버와 클라이언트가 소통하는 방식에 대한 약속입니다. HTTP 말고도 다양한 형태가 있습니다.
  - WebSocket
    - 실시간, 양방향 통신을 위한 프로토콜으로, HTTP 을 업그레이드한 연결 형태입니다.
  - TCP/IP , UDP
    - 직접 네트워크 레벨에서 TCP/IP 또는 UDP 를 사용할 수 있습니다. 이때 어플리케이션 개발자는 추가적인 프로토콜 레이어나 핸드쉐이킹, 데이터 전송 방식을 직접 관리해야 합니다.

- **그렇다면 마이크로서비스 형태에서 서로 다른 서버끼리 소통하는 상황을 봅시다. 이때는 서버끼리 어떠한 형태의 프로토콜을 사용해서 소통하는 것이 좋을까요?**

  - 서버끼리의 소통에는 **gRPC** 가 좋은 방법입니다. gRPC는 Google 에서 만든 RPC(Remote Procedure Call) 프로토콜입니다. 우선 gRPC는 서버-클라이언트 프로토콜이 아니라 서버끼리의 소통을 목적으로 만들어졌습니다. (웹 브라우저가 기본적으로는 gRPC 를 지원하지 않습니다.)
  - 첫번쨰로, gRPC 는 매우 간편하고, 확장성이 뛰어납니다. 각각 언어마다 HTTP 라이브러리가 있습니다. (예를 들어 파이썬은 HTTP 1.1 을 사용하는 `requests` 가 있고, Golang 은 HTTP 2.0 을 기본으로 하는 `http` 라이브러리가 있습니다.) 만약 마이크로서비스마다 다른 언어의 어플리케이션을 활용한다면, 이것들을 관리하는 것은 복잡합니다. gRPC 는 우리를 대신해서 HTTP 2.0 연결을 구현해줍니다. 또한, gRPC는 protocol buffer 를 사용해서 각 언어에 맞는 코드를 생성해줍니다. protocol buffer 는 소통을 위한 일종의 계약서입니다. 어떤 형태, 어떤 데이터를 주고 받을 지 사전에 정의합니다. protofile 에 정의를 하면, 각각 사용하는 언어를 바탕으로 코드를 생성합니다.
  - 두번째로는 성능입니다. gRPC 는 HTTP/2 를 기반으로 작동합니다. 또한, protocol buffer 는 바이너리 형태로 직렬화되고, 전송됩니다. 이것은 전통적인 json 을 전송하는 방식보다 훨씬 빠릅니다.

- **만약 클라이언트에서 10초가 지나면 무조건 timeout 이 된다면, 서버가 API 에 요청을 보내 10초 이상 기다린 후 response 받은 것을 어떤 방식으로 클라이언트에게 알려줄 수 있을까요? 프로토콜을 설계해도 됩니다.**
  - 우선 타임아웃이 Read Timeout 이라고 가정합시다. Read Timeout 은 클라이언트와 서버가 연결에는 성공했지만, 클라이언트가 원하는 요청에 대해 서버가 너무 오랫동안 응답을 못해 클라이언트가 연결을 해제하는 것입니다. 즉, 클라이언트에서 요청을 보낸 후 10초가 지나도 응답이 오지 않을때, 타임아웃이 발생하는 상황입니다.
  - 이때 생각해볼 수 있는 것은 비동기 응답 메커니즘입니다. 클라이언트가 요청을 보낼 때 서버는 요청을 비동기적으로 처리하고, 클라이언트는 응답을 기다리는 대신 즉시 반환된 요청 식별자를 사용하여 나중에 결과를 조회할 수 있습니다. 클라이언트는 반환된 요청 식별자를 사용하여 서버에 요청 상태를 주기적으로 조회합니다. 서버에서 요청 처리가 완료되면, 클라이언트가 조회 요청을 통해 상태를 확인할 때 결과를 전달하거나, 결과가 준비되었음을 알려주는 다른 메커니즘 (ex. Server Sent Event) 를 사용하여 클라이언트에게 알려줄 수 있습니다.
  - 이때 클라이언트가 계속 조회하는 방식은 폴링 또는 롱폴링 방식이 있습니다. 폴링 방식은 클라이언트가 일정한 주기로 서버에게 HTTP 요청을 보내는 방식입니다. 하지만 응답이 언제 올지 예측하기 어려우므로, 불필요한 HTTP 오버헤드가 발생합니다. 롱폴링 방식은 클라이언트가 HTTP 요청시 해당 요청을 일정 시간 동안 대기시킵니다. 만약 , 대기 시간 안에 데이터가 업데이트 되었다면, 그 순간 응답을 전달하고 연결을 종료합니다.
  - 반대로 서버 쪽에서 클라이언트에게 데이터가 준비되었음을 알려주는 메커니즘이 있습니다. Server-sent Events 를 사용하면 서버 -> 클라이언트 단방향으로 서버의 이벤트가 완료되었을 때 클라이언트로 메세지를 푸쉬할 수 있습니다.

### 26. 127.0.0.1 은 특별한 IP 주소입니다. 이 IP 주소의 의미는 무엇인가요?

127.0.0.1 은 루프백 혹은 로컬호스트 주소입니다. 호스트 A 가 호스트 b에게 패킷을 전달하고 싶을 때, 패킷에는 목적지인 B의 IP 주소가 담기게 됩니다. 만약 목적지 IP 주소를 127.0.0.1 로 설정하면, A의 네트워크 계층은 이 패킷을 외부로 전송하지 않고, 본인이 받은 것 처럼 처리합니다.

- **로컬호스트 주소는 어떤 용도로 사용되나요?**
  - 로컬호스트의 개념은 웹 개발과 테스트에 중요합니다. 로컬 서버를 사용하여 개발자들은 웹사이트나 어플리케이션을 실행함으로써, 모든 것이 올바르게 작동하는지 테스트할 수 있습니다. 또한 127.0.0.1 로 보내진 요청은 인터넷을 통과하지 않고 직접 컴퓨터 내에서 처리되기 때문에 오프라인 환경에서도 사용할 수 있습니다.

### 27. form-data 와 x-www-form-urlencoded 의 차이는 무엇인가요?
