## Java

<details>
<summary>📚 공부한 자료</summary>

- 자바의 정석

</details>

### 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요. ⭐️

JVM이란 _Java 언어와, Java bytecode 로 컴파일 된 다른 언어들도 실행할 수 있게 해주는 환경을 만들어주는 가상 머신_ 입니다. 프로그래머가 작성한 언어를 컴퓨터가 이해하고 실행하기 위해서는 기계어로 컴파일 해야 합니다. Java(\*.java) 를 Java bytecode(\*.class) 로 컴파일 하는 것은 java compiler 가 합니다. Java bytecode 를 실제 기계어로 해석하는 일을 JVM 이 담당합니다.

- **그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?**
  - 있습니다. JVM 은 Java bytecode를 인식합니다. 즉, Java bytecode 로 컴파일 될 수 있는 다른 언어들도 실행할 수 있습니다. 대표적으로는 Scala, Groovy, Kotlin 등이 있습니다.
- **반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?**

  - JVM 계열 언어도 직접 기계어로 변환해서 사용할 수 있습니다. 일부 JVM 구현체는 Ahead-Of-Time(AOT) 컴파일을 지원하여, 바이트코드를 실행 전에 기계어로 미리 컴파일할 수 있습니다.

- **JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?**
  - 전통적인 의미의 "부모 프로세스-자식 프로세스" 로 보는 것은 정확하지 않습니다. JVM이 실행될 때, 운영체제는 JVM을 위한 프로세스를 생성합니다. 이 JVM 프로세스 내에서 자바 프로그램이 실행되며, 이것은 운영체제에 의해 별도의 자식 프로세스가 생성되는 것이 아닌 JVM 프로세스의 일부로 실행됩니다. 따라서 JVM 내부에서 실행되는 자바 프로그램은 JVM 프로세스의 스레드로서 작동합니다.
- **Java bytecode란 무엇인가요?**
  - Java bytecode 란 JVM 이 이해할 수 있는 언어로 변환된 자바 소스코드입니다. Java 컴파일러에 의해 변환된 코드의 명령어 크가 1 byte 라서 바이트 코드라고 불립니다.
- **그렇다면 Java는 컴파일 언어일까요, 인터프리터 언어일까요?**
  - 자바는 컴파일, 인터프리터 방식 모두 사용합니다. 우선 자바 컴파일러가 자바 바이트코드 로 컴파일 한다는 면에서 컴파일 언어의 특성을 가지고 있습니다. 하지만 자바 바이트코드는 JVM의 자바 인터프리터가 한 줄씩 읽으면서 컴퓨터가 이해할 수 있는 바이너리 코드로 번역한 후 실행합니다. 이 부분은 인터프리터 언어의 특성을 가지고 있다고 볼 수 있습니다. 따라서 자바는 하이브리드 언어라는 이름으로 불립니다.
- **JVM의 동작 방식에 대해 간단하게 설명해주세요.**
  - 자바 프로그램을 실행하면 JVM 은 운영체제로부터 메모리를 할당받습니다. 그 후 자바 컴파일러가 자바 소스코드를 자바 바이트코드로 컴파일합니다. JVM의 클래스 로더는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 Runtime Data Area 에 올립니다. Runtime Data Area에 로딩된 바이트 코드는 실행엔진을 통해 명령어 단위로 해석되고 실행됩니다.
- **JVM의 구조에 대해 설명해주세요.**

  <details>
  <summary>JVM 구조</summary>

  - JVM

  ![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/2b417674-9775-408c-8bc5-25b877639daf)

  - Class Loader

  ![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/cbdce3f2-d119-4548-98ff-1b4bd55137cb)

  - Execution Engine

  ![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/ff138ec5-9227-4af8-8f03-aa79ade86093)

  - 출처 : [JVM 내부 구조 & 메모리 영역 💯 총정리](https://inpa.tistory.com/entry/JAVA-%E2%98%95-JVM-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD-%EC%8B%AC%ED%99%94%ED%8E%B8)

  </details>

  - JVM의 구조는 크게 **Class Loader, Runtime Data Area, Execution Engine** 영역으로 나눌 수 있습니다.
  - **클래스 로더**
    - 3가지 단계 (로딩, 링킹, 초기화) 으로 구성됩니다.
    - 우선 자바 컴파일러를 통해서 .class 확장자를 가진 클래스 파일은 각 디렉토리에 흩어져 있고, 기본적인 라이브러리들의 클래스 파일은 $JAVA_HOME 내부 경로에 존재합니다. 각각의 클래스 파일을 찾아서 JVM의 메모리 영역인 Runtime Data Areas 에 로드해주는 역할을 합니다. 두번째로는 로드된 클래스를 검증하고 기본값으로 초기화하는 링킹 과정도 합니다. 세번째로는 static field 의 값들을 정의한 값으로 초기화하는 과정도 합니다.
  - **실행 엔진**
    - 실행엔진에는 **JIT Compiler, Garbage Collector** 이 있습니다.
    - 실행 엔진은 **인터프리터**와 **JIT 컴파일러**를 이용해서 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행합니다. 일반적으로는 바이트 코드를 한 줄마다 읽어서 해석하고 바로 실행하는 인터프리터 방식으로 작동합니다. 하지만 매번 번역하는 작업은 번거롭기 때문에 특정 조건을 만족하면 JIT 컴파일러를 사용해 바이트코드전체를 컴파일하여 네이티브 코드로 변환합니다. 이후 같은 바이트코드에 대해서는 사전에 컴파일된 것을 캐시처럼 갖고 있다가 다시 사용할 수 있게끔 해줍니다.
    - 실행 엔진에는 **Garbace Collector(GC)** 도 포합되어 있습니다. GC는 JVM 상에서 더 이상 사용되지 않는 데이터가 할당되어있는 메모리를 해제시켜주는 장치입니다. GC가 동작하는 대상은, **Heap 영역** 내의 객체 중 참조되지 않는 데이터 입니다. GC가 주로 heap 영역을 대상으로 하는 이유는, heap 영역은 모두 공유되기 때문에, 하나의 메소드가 종료되어도 heap 영역의 데이터를 함부로 삭제할 수 없기 때문입니다. GC가 실행될때는 GC를 담당하는 쓰레드를 제외한 모든 쓰레드들은 작동이 일시적으로 정지되게 하는 Stop-the-World 현상이 발생합니다. 따라서 모든 쓰레드가 정지되기 때문에 성능이 저하됩니다. 그래서 적절한 빈도의 GC가 실행되도록 하는 점이 중요합니다.

- **JVM의 Runtime Data Area 영역은 무엇인가요?**
  <details>
  <summary>JVM Runtime Data Area </summary>

  ![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/9c92bb22-9439-4bf5-a40d-a332af92ed0a)

  - [JVM에 관하여 - Part 3, Run-Time Data Area](https://tecoble.techcourse.co.kr/post/2021-08-09-jvm-memory/)
  - [Chapter 2. The Structure of the Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se19/html/jvms-2.html#jvms-2.5.4)
  </details>

  - JVM Runtime Data Area 에는 크게 **Method Area, Heap, JVM Stacks, Native Method Stacks, PC registers** 가 존재합니다. Method Area, Heap 영역은 모든 쓰레드가 공유하고, JVM Stacks, PC registers ,Native Method Stacks 는 쓰레드 별로 생성되고 해당 쓰레드가 종료될 때 소멸됩니다.
  - **Method Area**(=Static Area)는 JVM 이 시작될 때 생성되고, 바이트코드를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간입니다. JVM이 동작하고 클래스가 로드될 때 적재되서 프로그램이 종료될 때까지 저장됩니다. 여기에는 run-time constant pool, 필드와 메서드 데이터, 메서드와 생성자를 위한 코드(클래스와 인스턴스 초기화에서 사용되는 스페셜 메서드) 를 저장합니다. 자바 파일의 필드 부분에서 선언된 전역변수와 정적 멤버 변수들의 데이터를 저장합니다.
  - **Heap** 영역은 메서드 영역과 함께 모든 쓰레드들이 공유하며, JVM 이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용되는 영역입니다. new 연산자로 생성되는 객체와 인스턴스 변수, 배열 타입 등 참조형 타입이 저장됩니다.
  - **Stack** 영역은 기본 자료형을 생성할 때 저장하는 공간으로, 임시적으로 사용되는 변수나 정보들이 저장되는 영역입니다. 메서드 호출 시마다 각각의 스택 프레임이 생성되고, 메서드 안에서 사용되는 값들을 저장하고, 호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장합니다.
  - **Native Method Stacks**는 JVM stack 과 비슷한 데이터들을 저장하지만, 자바가 아닌 다른 언어로 작성된 네이티브 메서드를 실행할 때 사용됩니다.
  - 스레드는 각자의 메서드를 실행합니다. 이때, 스레드 별로 동시에 실행하는 환경이 보장되어야 하므로 최근에 실행 중인 JVM에서는 명령어 주소값을 저장할 공간이 필요합니다. 이 부분을 **PC registers**가 관리하고 추적합니다. 즉, PC register 는 JVM에서 사용되었던 명령어 주소 값을 저장합니다.

- **JVM Stack 과 Heap 영역의 가장 큰 차이점은 무엇인가요?**

  - 힙 영역은 모든 스레드들이 공유하는 반면, 스택 영역은 스레드마다 각자의 메모리 공간을 가지고 있습니다.

- **만약 두 개의 스레드가 동시에 힙에 있는 메모리에 접근할 때 동시성 문제가 생길 수 있습니다. 구체적인 예시로는 어떤 것이 있을까요?**

  ```java
  count = 0
  count ++
  ```

  - 위의 코드에서 동시성 문제가 생길 수 있습니다. 두 개의 스레드에서 `count++` 를 하면 기대값은 2가 되야 하는데, 결과값이 1인 경우가 생길 수 있습니다. `count++` 의 경우 실제로 CPU는 count read, count increase, count write 3가지 단계의 연산으로 나누어 실행합니다. 이 3가지 단계의 연산을 두 개의 스레드에서 실행할 때, 하나의 스레드가 read 단계까지만 수행한 후 OS 스케쥴러가 다른 스레드에 CPU 를 할당시켜줄 수 있습니다. 그러면 다른 스레드도 read 단계에서 count 값이 0이라고 인식합니다. 다시 원래 스레드가 CPU 를 할당받아서 increase, write 까지 수행해도 다른 스레드에서는 이미 0 을 read 했기 때문에 값이 똑같이 1로 write 됩니다. 이것은 `count++` 연산이 원자성이 보장되지 않아서 생기는 문제입니다.

- **스레드이 메서드별로 스택이 할당 되는데, 메서드가 종료되게 되면 그 메서드 안에서 아용된 로컬 변수가 쓸모 없어지기 때문에 메모리 해제가 되는데, 만약 메서드 안에서 선언한 변수가 참조형 타입인 경우에는 어떤 식으로 메모리가 사용되나요?**

  - 우선, 참조형 타입의 경우에는 스택 영역에 실제 객체의 주소가 저장되고, 스택 영역에는 그 객체의 주소값이 저장됩니다. 따라서 메서드가 종료되면 스택이 사라지면서 그 객체의 주소값을 저장하고 있는 참조변수가 사라지게 됩니다. 그렇게 아무런 참조변수가 힙 영역의 객체를 참조하고 있지 않으면, GC가 객체를 Unreachable 로 판단하여 제거합니다.

- **Java 메모리 영역 중 Stack 과 Heap 에는 각각 어떤 것이 저장되나요?**

  - 자바에서 stack 영역은 스레드마다 하나씩 존재하며, 스레드 내에서 실행되는 각 메서드 호출 정보에 대한 정보를 저장하는 공간입니다. 메서드가 호출될 때마다 해당 메서드를 위한 프레임이 스택에 추가(push) 되며, 메서드가 종료될 때 해당 프레임은 스택에서 제거(pop) 됩니다. 프레임 내에는 지역 변수, 매개 변수, 연산 중간 결과와 같은 값들이 저장되어 있습니다.
  - Heap 영역은 JVM 전체에서 공유되는 메모리 영역으로, 모든 스레드가 접근할 수 있습니다. 자바에서 동적으로 할당된 객체와 배열이 이 영역에 할당됩니다. 즉, `new` 키워드를 사용해서 생성된 모든 객체와 배열이 여기에 저장됩니다. Heap 영역은 가비지 컬렉터(Garbage Collector)에 의해 관리되며, 더 이상 참조되지 않는 객체들은 가비지 컬렉터에 의해 자동으로 메모리에서 제거됩니다.

- **기본형 데이터 타입과 참조형 데이터 타입의 실제 값은 각각 어느 영역에 저장되나요?**

  - 기본 데이터 타입 변수(ex. int, float, boolean..) 는 실제 값이 스택 영역에 저장되고, 참조 타입 변수는 실제 객체의 값은 heap 영역에 저장되지만 해당 객체를 가리키는 참조 값(메모리 주소)는 스택 프레임 내 저장됩니다.

- **그렇다면, `Person p = new Person()` 를 실행했을 때 `p` 와 `Person() 객체` 는 각각 어느 영역에 저장되나요?**

  - new 에 의해 생성된 객체는 힙 영역에 저장되고, 스택 영역에는 생성된 객체의 참조인 p 가 저장됩니다.

- **Java 메모리의 있는 스택 프레임은 메서드가 종료되면 사라집니다. 하지만 힙 영역에 있는 객체들은 메서드가 종료되도 메모리에 남아 있습니다. 왜 그럴까요?**
  - 객체가 메서드 종료 후에도 메모리에 남아 있는 이유는 객체의 생명주기가 해당 객체를 생성한 메서드의 생명주기와 독립적이기 때문입니다. 객체는 힙 영역에 저장되며, 이 영역은 JVM 내 다른 스레드에서도 접근할 수 있습니다. 객체가 어떤 메서드에서 생성되었더라도, 다른 메서드에서 이 객체에 대한 참조를 가지고 있다면, 그 객체는 여전히 유효하고 접근 가능합니다. 따라서 객체의 생명은 참조가 있는 동안 계속되며, 모든 참조가 사라지고 나서야 GC에 의해 메모리에서 제거될 수 있습니다.
- **Static 영역과 Heap 영역의 공통점과 차이점은 무엇인가요?**
  - 스태틱 영역(=Method 영역) 과 힙 영역 모두 모든 쓰레드가 공유한다는 공통점이 있습니다.
  - 프로그래머가 만든 Class 는 스태틱 영역에 저장되고, `new` 연산을 통해 생성한 객체는 힙 영역에 생성됩니다. 객체의 생성시에 할당된 힙영역 메모리는 GC를 통해 수시로 관리합니다. 하지만 스태틱 영역에 할당된 메모리는 GC의 영역 밖에 존재합니다.

### 2. final 키워드를 사용하면, 어떤 이점이 있나요?

`final` 키워드는 자바에서 변수, 메서드, 클래스에 대한 변경을 제한하기 위해 사용됩니다.

- 변수에 `final` 이 사용되는 경우

  - `final` 변수는 멀티스레드 환경에서 공유될 때 추가적인 동기화 없이도 작업이 안전하다는 것을 보장합니다. (thread-safe)
  - 원시 변수에 `final` 로 선언하면 한번 초기화된 변수는 변경할 수 없는 상수값이 됩니다. (`final int x = 1`)
  - 객체 변수에 `final` 로 선언하면, 그 변수에 다른 참조 값을 지정할 수 없습니다. 단, 객체 자체가 immutable 하다는 의미는 아니며, 객체의 속성은 변경 가능합니다.

  ```java
      public void test_final_reference_variables() {
        final Pet pet = new Pet();
        // pet = new Pet(); //다른 객체로 변경할수 없음

        pet.setWeight(3); //객체 필드는 변경할 수 있음

    }
  ```

- 메서드에 `final` 이 사용되는 경우
  - `final` 로 선언된 메서드는 하위 클래스에서 오버라이드할 수 없습니다. 따라서 `final` 로 선언된 메서드는 컴파일 시점에 어느 클래스가 실행될 지 알 수 있으며, 정적 디스패치가 가능하여, 동적 디스패치보다 실행 시간을 단축할 수 있습니다.
- 클래스에 `final` 이 사용되는 경우

  - `final` 로 선언된 클래스는 상속될 수 없습니다. 이는 컴파일러가 클래스의 모든 메서드를 자동으로 `final` 메서드로 취급할 수 있게 합니다.

- **그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?**
  - `final`로 선언된 변수가 컴파일 시점에 리터럴 값으로 초기화된 경우, 컴파일러는 이 변수를 상수로 취급하고 해당 변수가 사용된 모든 위치를 실제 값으로 대체할 수 있습니다.
  - `final` 로 선언된 메서드는 오버라이딩이 불가능하기 때문에, 컴파일러와 JVM은 이 메서드를 호출하는 부분에 메서드의 본문을 직접 삽입하는 최적화(인라이닝)을 수행할 수 있습니다. 이는 메서드 호출에 대한 오버헤드를 줄이고 성능을 향상시킵니다.
  - `final` 로 선언된 클래스는 상속될 수 없으므로, 컴파일러는 `final` 클래스의 모든 메서드들을 자동으로 `final` 취급합니다. 따라서 클래스와 관련된 다이나믹 디스패치가 필요 없으므로 컴파일러는 더 효율적인 코드를 생성할 수 있습니다.

### 3. 변수는 어떤 것인가요?

변수란 단 하나의 값을 저장할 수 있는 메모리 공간입니다. 변수를 사용하려면 변수를 선언하고, 변수를 초기화해야 합니다. 변수의 자료형에는 크게 기본형(primitive), 참조형(reference) 두 가지로 나눌 수 있는데, 기본형 변수는 실제 값을 저장하는 반면, 참조형 변수는 어떤 값이 저장되어 있는 주소를 값으로 갖습니다. 기본형 변수에는 논리형(boolean), 문자형(char), 정수형(byte,short,int,long), 실수형(float,double) 이 있습니다.

- **참조형 변수에서 실제 값을 저장하지 않고 주소값을 저장하는 이유는 무엇인가요?**

  - 참조형 변수에서 참조값은 각 스레드 내의 스택 영역에 저장되고, 실제 객체 데이터는 JVM내 스레드들이 공유하는 힙 영역에 저장됩니다. 이때 객체 데이터의 크기는 매우 클 수 도 있고, 데이터의 크기는 변화할 수 있습니다. 따라서 메모리 주소만 저장함으로써 메모리 사용을 더욱 효율적으로 관리할 수 있습니다. 또한 참조를 통해 여러 변수가 동일한 객체를 가리킬 수 있으므로, 데이터가 중복되어 저장되는 것을 방지합니다.

- **그렇다면 기본형 변수는 스택 영역 내에 실제 값을 저장하는 이유는 무엇인가요?**

  - 기본형 변수는 고정된 크기를 가지며, 이들의 처리는 참조형 변수에 비해 상대적으로 단순하고 빠릅니다. 스택 영역은 메서드 호출과 함께 실행 컨텍스트를 저장하는 공간입니다. 여기에 저장된 변수는 메서드 실행 동안 빠르게 접근되고, 메서드 종료 시 함께 소멸되므로 메모리 관리가 효율적입니다. 또한 기본형 변수는 고정된 크기를 사용하므로, 스택에 할당하기 적합합니다.

- **변수와 상수의 차이는 무엇인가요?**
  - 변수와 상수는 데이터를 저장하는 컨테이너라는 공통점이 있지만, 그 값을 변경할 수 있는지 여부에 따라 차이가 있습니다. 프로그램 실행 중에 변수에 저장된 값은 변경될 수 있습니다. 변수는 프로그램이 실행되는 동안 정보를 저장하고, 수정하며, 참조하기 위해 사용됩니다. 반면 상수는 한 번 값이 할당되면 프로그램 실행 도중 그 값이 변경될 수 없는 메모리 공간입니다. 자바에서는 `final` 키워드를 통해 상수를 선언합니다.

### 4. 부동소수점이 무엇인가요?

컴퓨터에서 실수를 표현하는 방식으로는 대표적으로는 고정 소수점 방식(fixed-point number representation) 과 부동 소수점 방식(floating-point number representation) 으로 나눌 수 있습니다. 자바의 float 타입을 기준으로, 실수 메모리는 총 32비트를 할당받습니다. 부동소수점은 정수부, 소수부가 16비트로 나누어져 있는 고정 소수점 방식과 달리 메모리를 가수부(23bit)와 지수부(8bit)로 나눕니다. 가수부에는 실제 실수 데이터 비트들이 들어가고, 지수부에는 소수점의 위치를 가리키는 제곱승이 들어갑니다. 따라서 부동소수점을 사용하면 더 큰 범위의 값을 표현할 수 있습니다.

- **부동소수점을 사용하면, 소수 계산 오차 문제가 사라지나요?**

  - 아닙니다. 0.625 같이 이진수 소수점으로 딱 떨어지는 수 도 있지만, 0.1과 같이 무한 반복되는 이진수 실수는 아무리 큰 수를 저장하는 부동소수점 방식이라 하더라도 무한대를 저장할 수 없으므로 메모리 한계까지 소수점을 집어넣고 어느 부분에서 끊어 반올림을 해주어야 합니다. 이를 무한 소수라고 합니다. 이러한 무한 소수 때문에 부정확한 실수의 계산결과가 생기게 됩니다.

- **자바에서 실수형 계산을 정확하게 하기 위해서는 어떻게 해야 하나요?**

  - 자바에서는 2가지 방법을 제공하는데, 첫번째는 int,long 정수형 타입으로 치환하고 사용하는 방법과 두번째는 BigDecimal 클래스를 이용하는 방법입니다.
  - 첫번째 방법은 예를 들어 23.25에 100을 곱해서 2535로 정수로 치환해서 계산하고 다시 100으로 나누는 방법입니다.
  - 첫번째 방법으로는 소수의 크기가 18자리를 초과하는 경우 int,long 타입으로 표현할 수 없기에 BigDecimal 클래스를 사용해야 합니다. BigDecimal 타입은 내부적으로 수를 십진수로 저장하여 아주 작은 수와 아주 큰 수의 연산에 대해 무한한 정밀도를 보장합니다.

- **그렇다면 BigDecimal 은 실수를 어떤 형태로 저장하나요?**

  - BigDecimal 은 int 의 배열로 저장합니다. 큰 숫자를 배열에 나눠 담는 형식으로 구현됩니다. BigDecimal 은 임의 정밀도 정수형인 unscaled value 와 소수점 오른쪽의 자릿수를 나타내는 32bit 정수인 scale 로 구성됩니다. 만약 3.14 의 경우 unscaled value 는 314, scale 은 2가 됩니다.

  ```java
  package java.math;

  public class BigDecimal extends Number implements Comparable<BigDecimal> {

      private final BigInteger intVal; // = unscaled value
      private final int scale; // 소수점 오른쪽의 자릿수
      private transient int precision; // 총 자릿수
      private final transient long intCompact;
      ...
  ```

### 5. `==` 과 `equals` 의 차이점은 무엇인가요?

- `==` 연산자

  - **스택 메모리에 있는 값을 비교**하는 연산자입니다.
  - 기본형 타입의 경우, 스택 메모리에 값 자체가 저장되기 때문에 데이터의 값을 비교합니다.반면 참조형 타입의 경우 객체의 주소가 스택 메모리에 저장되어 있기 때문에, 주소값을 비교합니다. 따라서 객체의 값이 같더라도 주소값이 다르다면 false 를 반환합니다.

- `equals()` 메서드

  - `equals()` 메서드는 객체의 내용 자체를 비교하는 데 사용됩니다. `Object` 클래스에서 상속받은 `equals()` 메서드는 기본적으로 `==` 연산자와 동일하게 객체의 참조를 비교합니다. 하지만, 대부분의 클래스 (String, Integer 등 자바 표준 클래스) 에서는 `equals()` 메서드를 오버라이드하여 객체의 내용을 비교하도록 구현합니다. 이렇게 오버라이드된 `equals()` 메서드는 두 객체의 실제 데이터 값을 비교하여, 내용이 같다면 `true`를 반환합니다.

- **Object 의 `equals` 메서드는 어떻게 구현되어 있나요?**

  ```java
  // Object equals() 메서드
  public boolean equals(Object obj) {
    return (this == obj);
  }
  ```

  - Object 의 `equals()` 메서드는 두 참조가 실제로 같은 객체를 가리키는지 확인합니다. 이 기본 구현은 참조 동등성만 고려하기 때문에, 객체의 논리적 동등성(logical equality)를 비교하려면 `equals()` 메서드를 오버라이드 해야 합니다.
  - 예를 들어 **String** 클래스에서는 `equals()` 메서드를 아래와 같이 오버라이드 하여 문자열의 내용이 같은지 비교합니다. 첫번째로 현재 객체(`this`) 와 비교 대상 객체(`anObject`) 의 참조를 비교해서 같은 메모리 주소를 가리키면 `true` 를 반환합니다. 만약 메모리 주소가 같지 않더라도, 논리적 동등성을 확인합니다. 우선 `anObject instanceof String aString` 부분은 `anObject` 가 `String` 타입인지 확인하고, 현재 문자열과 비교 대상 문자열의 내부 표현 방식(`coder`)이 같은지 비교합니다. 마지막으로 `StringLatin1.equals(value, aString.value)` 를 통해 두 문자열이 같은 값을 가지고 있는지 확인합니다.

    ```java
    // String equals() 메서드
    public boolean equals(Object anObject) {
          if (this == anObject) {
              return true;
          }
          return (anObject instanceof String aString)
                  && (!COMPACT_STRINGS || this.coder == aString.coder)
                  && StringLatin1.equals(value, aString.value);
      }
    ```

  - Integer 클래스에서는 `equals()` 메서드를 아래와 같이 오버라이드 하여 Integer 객체 내부 값이 같은지 비교합니다.

    ```java
    // Integer equals() 메서드
    public boolean equals(Object obj) {
      if (obj instanceof Integer) {
          return value == ((Integer)obj).intValue();
      }
      return false;
    }
    ```

- **아래의 코드는 어떤 결과가 나올까요? 이유를 설명해보세요.**

  ```java
  Integer a = new Integer(3);
  Integer b = new Integer(3);
  System.out.println(a==b);
  ```

  - 위의 코드는 `false` 를 반환합니다. `==` 연산자는 두 객체의 참조를 비교합니다. 즉, 두 객체가 메모리 상에서 같은 위치를 가리키는지 확인합니다. 코드에서 `a` 와 `b` 는 `Integer` 클래스의 인스턴스이며, `new Integer(3)` 을 통해 각각 생성됩니다. `new` 키워드를 사용하면 자바 힙 메모리에 새로운 객체가 할당됩니다. 따라서 `a`,`b` 는 내용은 같지만 실제로는 메모리 상의 서로 다른 위치에 있는 별개의 객체입니다.

- **그럼, `equals()` 와 `hashCode()` 에 대해 설명해 주세요.**

  - `hashCode()` 메서드는 객체의 주소값을 이용해서 해싱 기법을 통해 해시 코드를 만든 후 반환합니다. 그렇기 때문에 서로 다른 두 객체는 같은 해시 코드를 가질 수 없게 됩니다.

- **`hashCode()` 의 용도는 무엇인가요?**

  - `hashCode()` 의 용도는 하나의 객체에 대한 해시코드 값을 만드는 것입니다. 해시코드는 Hash table, Hash map 등 해시를 사용하는 자료구조에서 해시 함수 의 용도로 쓰입니다. Object 클래스 내에 정의된 `hashCode()`는 객체의 주소를 이용하는 알고리즘으로 해시코드를 만들어 내기 때문에 모든 객체에 대해 `hashCode()` 를 호출한 결과가 서로 유일한 훌륭한 방법입니다.

- **본인이 `hashCode()` 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?**

  - 자바에는 `equals()` 의 결과가 `true` 인 두 객체의 해시코드는 반드시 같아야 한다는 규칙이 있습니다. 따라서 `equals()` 를 오버라이딩 했다면, `hashCode()` 도 오버라이딩 해야 합니다. 두 메서드를 같이 재정의하지 않을 시, hash 값을 이용하는 Collection Framework (HashSet, HashMap, HashTable) 을 사용할 때 문제가 생깁니다.
  - 조금 더 자세히 설명하자면, `hashCode()` 와 `equals()` 의 동작 순서를 알아야 합니다. 우선 컬렉션에 데이터를 추가할 때, 그 데이터의 `hashCode()` 리턴 값을 컬렉션이 가지고 있는지 비교합니다. 만일 해시코드가 같다면 그제서야 다음으로 `equals()` 메서드의 리턴값을 비교하게 되고, true 이면 논리적으로 같은 객체라고 판단합니다. 만약 `equals()`만 재정의하고 `hashCode()`를 재정의하지 않는다면, HashSet 또는 HashMap 등 해싱을 구현한 컬렉션 클래스에는 `equals()` 호출 결과가 true 지만 해시코드가 다른 두 객체를 서로 다른 것으로 인식하고 따로 저장하는 문제가 생깁니다.

- **그렇다면 `equals()` 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.**

  - `equals()` 를 재정의 할 때, 다음의 순서대로 재정의합니다.
  - 순서1. 두 객체가 동일한 참조 값을 가지는지 확인합니다. 둘 다 동일한 참조 값을 가지는 경우 데이터도 동일하므로 true 를 반환하도록 합니다.
  - 순서2. 매개변수로 전달받는 객체가 null 이거나 두 객체가 동일한 타입이 아니라면, false 를 반환하도록 합니다.
  - 순서3. 매개변수로 전달받은 매개변수를 현재 클래스 타입으로 반환합니다.
  - 순서4. 모든 필드의 값을 비교합니다. 기본 타입이라면 `==` 연산자를 사용하고 참조 타입인 경우 Objects 클래스의 `equals()` 메서드를 사용할 수 있습니다.

- **만약 `equals()` 와 `hashCode()` 를 둘 다 재정의 했을 때, 객체의 주소값을 비교해야 한다는 상황이 온다면 어떻게 하나요?**
  - 자바에서는 똑같이 해시코드를 반환해주는 또 다른 메서드인 `identityHashCode()` 가 있습니다. 만약 `hashCode()` 를 오버라이딩 해서 쓰는데, 오버라이딩 하기 전의 원조 기능이 필요할때 사용 하는 메서드입니다.

### 6. 다형성은 무엇인가요? 또 언제 활용할 수 있을까요?

다형성은 객체 지향 프로그래밍의 핵심 원리 중 하나로, "많은 형태를 가질 수 있는 능력"을 의미합니다. 다형성은 같은 인터페이스나 메서드 호출이지만, 다양한 객체애 대해 다른 방식으로 작동할 수 있게 해줍니다. 자바에서 다형성은 주로 상속과 인터페이스를 통해 구현됩니다.

다형성은 두 가지 주요 형태로 나타납니다.

- 컴파일 타임 다형성(정적 다형성) : 메서드 오버로딩을 통해 구현됩니다. 이는 같은 클래스 내에서 메서드 이름이 같지만, 매개변수의 타입이나 개수가 다른 여러 메서드를 정의할 수 있게 해줍니다. 컴파일러는 메서드를 호출때 제공된 인자에 기반하여 어떤 메서드를 사용할 지 결정합니다.
- 런타임 다형성(동적 다형성) : 상속과 인터페이스를 활용한 메서드 오버라이딩을 통해 구현됩니다. 상위 클래스 또는 인터페이스 타입의 참조 벼수가 다양한 하위 클래스의 객체를 참조할 수 있으며, 실행 시간에 어떤 클래스의 메서드를 호출할지 결정됩니다. 이것은 같은 인터페이스를 구현하거나 같은 클래스를 상속받은 다양한 객체들이 있을 때, 이들 객체를 동일한 방식으로 처리할 수 있게 해줍니다.

### 7. 인터페이스와 추상클래스의 차이점은 무엇일까요?

- 인터페이스

  - 내부의 모든 메서드는 `public abstract` 로 정의 (`default` 메서드 제외) 하고, 내부의 모든 필드는 `public static final` 상수 입니다. 하나의 클래스가 여러 인터페이스를 구현할 수 있습니다. 이때 `implements` 키워드를 사용하여 구현합니다.
  - 인터페이스 자체를 확장시키고 싶다면, `extends` 를 통해 인터페이스를 상속하면 됩니다. 클래스와 달리 인터페이스 끼리의 상속은 다중 상속이 가능합니다. 왜냐하면 메서드 구현부가 없으므로 충돌 가능성이 없기 때문입니다.

  ```java
  interface TV {
    int MAX_VOLUME = 10; // public static final 생략 가능
    int MIN_VOLUME = 0;

    default boolean turnOn(boolean state){ // default method
      state = true;
      return state
    }
    default boolean turnOff(boolean state){
      state = false
      return state
    }
    void changeVolume(int volume); // public abstract 생략 가능
    void changeChannel(int channel);
  }
  ```

- 추상클래스

  - 추상클래스는 하나 이상의 추상 메서드를 포함한 클래스입니다. 추상 클래스는 인스턴스 변수, 인스턴스 메서드를 가질 수 있습니다. 추상 클래스를 상속 받는 하위 클래스에서 추상 메서드를 구현해야 합니다. 추상클래스는 `new` 생성자를 통해 인스턴스 객체로 직접 만들 수 없고, 반드시 어느 자식의 클래스에 상속시키고 자식 클래스를 인스턴스화 해서 사용해야 합니다.

  ```java
  abstract class Pet {
    abstract public void walk(); // 추상 메소드 -> 상속받은 자식 클래스가 구현
    abstract public void eat(); // 추상 메소드 -> 상속받은 자식 클래스가 구현

    public int health; // 인스턴스 필드
    public void run() {  // 인스턴스 메소드
      System.out.println("run run");
    }
  }
  ```

- 인터페이스 vs 추상클래스

  - 추상 클래스는 상속 받아서 기능을 확장시키는 데 목적을 둡니다. 반면에 인터페이스는 구현 객체의 동일한 실행 기능을 보장하기 위한 목적입니다. 키워드에서도 의미를 볼 수 있는데, 추상클래스는 `extends` 키워드를 사용하여, 자신의 기능들을 하위로 확장시키는 것입니다. 반면에 인터페이스는 `implements` 키워드를 사용하여, 인터페이스에 정의된 메서드를 각 클래스의 목적에 맞게 구현하는 것으로 볼 수 있습니다.
  - 또 다른 관점에서는 추상 클래스는 이를 상속할 각 객체들의 공통점을 찾아 추상화 시켜놓은 것으로 상속 관계를 타고 올라갔을 때, 같은 부모 클래스를 상속하며 _부모 클래스가 가진 기능들을 구현해야 하는 경우_ 에 사용합니다. 반면 인터페이스는 상속 관계를 타고 올라갔을 때 다른 부모 클래스를 상속하더라도 *같은 기능이 필요한 경우* 에 사용됩니다.

- **왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?**

  - 다중 상속을 하게 되면, 두 상위 클래스가 동일한 시그니처(메서드의 접근 제어자, 리턴 타입, 메서드 명, 매개변수가 모두 동일함)를 가진 동일한 메서드를 가지고 있을 때 하위 클래스가 어느 쪽의 메서드를 상속받을지 명확하지 않은 문제가 발생할 수 있습니다. 하지만 인터페이스는 위의 문제를 피해갈 수 있습니다. 왜냐하면 메서드가 정의되지 않았기 때문입니다. 부모 중 아무거나 상속받아도, 어차피 해당 메서드는 구현되지 않아 자식 클래스에서 새롭게 정의해야 합니다.

- **인터페이스에서, `default method` 란 어떤 것인가요? 어떤 상황에서 주로 사용되나요?**

  - 만약 5개의 클래스 (class A, ... Class E) 가 인터페이스 A 를 구현하고 있다고 해봅시다. 이때, 요구사항이 추가되어 인터페이스A에 특정 추상 메서드 methodA 를 추가해야 한다고 생각해봅시다. 그렇다면 인터페이스 원칙에 의해 class A, ... Class E 에 모두 methodA 를 구현해야 합니다. 이것은 '소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다' 는 개방 폐쇄 원칙(OCP) 에 어긋나는 경우입니다. 따라서 Java8 에서부터 인터페이스에도 구현된 몸통이 있는 `default` 메서드가 생겼습니다.
  - `default method` 는 인터페이스에 있는 구현 메서드를 의미합니다. 기존의 추상 메서드와 다른 점은 메서드 앞에 `default` 예약어를 붙이고, 구현부 `{}` 가 있어야 한다는 점입니다. `default method` 를 사용하면, 추가 변경을 막을 수 있어 OCP 를 지키는 코드를 작성할 수 있습니다. `default method` 는 인터페이스를 구현한 클래스에서 코드를 구현할 의무는 없지만, 원한다면 재정의할 수 있습니다.
  - 보통 인터페이스를 구현한 이후, 수정과정에서 인터페이스 모든 구현체에게 광역으로 함수를 만들어주고 싶을 때 사용합니다.

- **클래스A 가 인터페이스A, 인터페이스B 를 구현한다고 합시다. 만약 인터페이스A, 인터페이스B 에 동일한 시그니처를 가진 동일한 default method 가 있을 때, 다중 상속의 문제점이 발생하나요? 이것을 어떻게 해결하나요?**

  - 첫번째 방법으로는 명시적인 메서드 오버라이드가 있습니다. 클래스A 는 두 인터페이스의 `default` 메서드를 명시적으로 오버라이드(재정의)하고, 자신의 구현을 제공해야 합니다. 두번째로는, 만약 클래스가 두 인터페이스의 `default` 메서드 중 하나를 선택하여 사용하려면, 해당 메서드를 오버라이드하고, 선택된 인터페이스의 `default` 메서드를 명시적으로 호출해야 합니다.

  ```java
  // classA 가 InterfaceA , InterfaceB 의 default method(someMethod()) 를 오버라이드
  @Override
  public void someMethod() {
    InterfaceA.super.someMethod(); // InterfaceA 의 default method 를 사용한다고 명시적으로 호출
  }
  ```

### 8. A 라는클래스에 특정코드를 주고 싶을때, 상속과 조합의 차이는 무엇이고, 각각의 장점을 설명해주세요.

- **상속(Inheritance)**
  - 상속은 한 클래스가 다른 클래스의 속성과 메서드를 확장(상속)할 수 있도록 하는 메커니즘입니다. 상속을 통해, 하위 클래스(subclass)는 상위 클래스(superclass)의 모든 public과 protected 멤버를 재사용할 수 있습니다. 하지만 상위 클래스의 구현이 하위 클래스에게 노출되는 상속은 캡슐화를 깨뜨립니다. 만약 상위 클래스에서 메서드 이름이나 매개변수가 변화하면 하위 클래스 전체에서 변경해주어야 합니다. 이처럼 상속은 하위 클래스가 상위 클래스에 강하게 결합, 의존하게 되고 강한 결합, 의존은 변화에 유연하게 대처하기 어려워집니다.
  - 따라서 상속은 확장을 고려하고 설계한 확실한 'is-a' 관계일 때 사용해야 합니다.
- **조합(Composition)**
  - 조합은 기존 클래스가 새로운 클래스의 구성요소로 쓰이는 방식입니다. 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조한다. 조합을 사용하면, 한 클래스가 다른 클래스의 기능을 '가지고 있는(has-a)' 관계를 형성합니다. 새로운 클래스에서는 기존 클래스의 메서드를 호출하는 방식으로 동작합니다. 이 때문에 캡슐화를 깨뜨리지 않고, 기존의 클래스가 변화에도 새로운 클래스에는 미치는 영향이 적습니다.

### 9. 리플렉션에 대해 설명해 주세요.

리플렉션이란 프로그램 실행 중에, 사용자와 운영체제 및 기타 프로그램과 상호작용 하면서 클래스와 인터페이스를 검사하고 조작할 수 있는 기능입니다. 자바 소스코드를 실행하면, 자바 컴파일러가 소스코드를 자바 바이트코드로 변환하고, 이것을 클래스 로더가 JVM Runtime Data Area 에 올려주게 됩니다. 그 중 Method Area 에 클래스에 대한 메타 데이터를 저장합니다. 따라서 리플렉션은 Method Area 에 있는 메타데이터를 가지고 런타임에 클래스를 검사하고 조작합니다.

- **의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?**

  - 리플렉션을 사용하면, 런타임에 클래스의 private 필드나 메서드에 접근하고, 수정할 수 있습니다. 이러한 능력은 캡슐화와 정보 은닉 원칙을 위반할 수 있습니다. 또한 private 메서드를 호출하거나 변경함으로써 객체의 안정성을 해칠 수 있습니다.
  - 보안 문제 방지를 위해서는 여러 가지 방법이 있습니다. 첫번째로는 접근 제어입니다. `java.lang.reflect.AccessibleObject`의 `setAccessible` 메서드를 사용하여 private 멤버에 대한 접근을 가능하게 할 수 있습니다. 하지만, 보안 관리자(Security Manager)를 설정하고, 적절한 권한을 부여하지 않으면 이러한 접근을 제한할 수 있습니다.

- **리플렉션을 언제 활용할 수 있을까요?**
  - 많은 라이브러리와 프레임워크에서 리플렉션을 활용합니다. 라이브러리와 프레임워크에서는 사용자가 컴파일하기 전까지 객체의 타입을 알 수 없습니다. 이러한 문제를 동적으로 해결하기 위해 리플렉션을 사용합니다. Spring 의 의존성 주입, Hibernate 의 ORM 매핑, JUnit 의 어노테이션 기반 테스트 실행 등에서 활용됩니다.

### 10. static class와 static method를 비교해 주세요.

- **static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?**
- **컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.**

### 11. 자바에서 `new` 키워드를 사용하면 어떤 일이 일어나나요? 메모리 관점에서 자세히 설명해주세요.

### 12. 자바에서 스레드 풀(Thread Pool) 이란 어떤 것이고 언제 사용하나요?

풀(Pool) 이란 자원을 사용하는 시점에서 메모리에 올리고, 사용을 완료한 이후 메모리에서 해제하는 대신 _이미 사용할 준비가 된 자원을 메모리 위에 일정량 미리 생성해둔 자원의 집합_ 입니다. 자원이 필요한 경우 새로 자원을 생성하는 대신 풀에서 꺼내 사용하고, 사용이 완료된 경우 자원을 해제하는 대신 풀에 다시 반환하는 형태로 사용합니다. 자원을 미리 생성해두면 자원이 필요할 때 자원의 생성, 파괴 비용을 절약할 수 있습니다. 즉, 오버헤드를 줄일 수 있습니다.

쓰레드 풀이란 쓰레드를 미리 생성하고, 작업 요청이 발생할 때 마다 미리 생성된 쓰레드로 해당 작업을 처리하는 방식을 의미합니다. 이때, 작업이 끝난 쓰레드는 종료되지 않으며 다음 작업 요청이 들어올 때까지 대기합니다. 쓰레드 풀을 사용하면 이런 쓰레드 폭증으로 인한 애플리케이션 성능 저하를 방지할 수 있습니다. 쓰레드를 제한된 개수로 생성한 뒤, 들어오는 작업을 작업 큐(task queue)에 채워 넣은뒤 쓰레드 별로 할당하여 작업을 처리합니다.

### 13. Error 와 Exception 의 차이가 무엇인가요?

<details>
<summary>Error, Exception</summary>

![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/a53b853e-5009-40a1-9c16-a051acd15f14)

</details>

자바에서 Error 와 Exception 은 모두 Throwable 클래스를 상속받지만, 사용 목적과 처리 방법에서 중요한 차이가 있습니다.

**오류(Error**)는 시스템이 종료되어야 할 수준의 상황과 같이 프로그래머가 수습할 수 없는 심각한 문제를 의미합니다. 프로그래머가 미리 예측하여 방지할 수 없습니다. 오류의 예시로는 `OutOfMemoryError`, `StackOverflowError`, `NoClassDefFoundError` 등이 있습니다. 이들은 시스템 레벨의 예외로, 자원 부족 또는 구성 오류와 같은 심각한 상황을 나타냅니다.

반면 **예외(Exception)**는 프로그래머가 구현한 로직에서 발생한 실수나 사용자의 영향에 의해 발생합니다. 오류와 달리 개발자가 예외를 캐치하여 어플리케이션 중단을 방지할 수 있기 때문에 상황에 맞는 예외처리를 해야 합니다. 예외에는 체크 예외(Checked Exception) 과 언체크 예외(Unchecked Exception) 이 있습니다.

- **체크 예외와 언체크 예외의 차이는 무엇인가요?**

  - Checked Exception
    - 컴파일 시점에 체크되는 예외로, `Exception` 클래스를 상속받고, `RuntimeException` 클래스는 상속받지 않는 예외들입니다. `IOException`, `SQLException` 등이 있습니다. Checked Exception은 반드시 try-catch 블록으로 처리하거나, 메서드 시그니처에 throws 키워드를 사용하여 선언해야 합니다.
  - Unchecked Exception

    - 런타임에 발생하는 예외로, `RuntimeException` 클래스와 그 하위 클래스들입니다. 프로그램 로직 상 잘못된 부분을 뜻합니다. 예를 들어, , 배열의 인덱스가 범위를 벗어날 때 발생하는 `IndexOutOfBoundsException` , 0으로 나눌 때 발생하는 `ArithmeticException`, 객체의 참조가 null일때 발생하는 `NullPointerException`, 은 메서드에 전달된 인자가 부적절할 때 발생하는 `IllegalArgumentException` 등이 있습니다. Unchecked Exception은 선택적으로 처리할 수 있으며, 프로그램의 버그나 잘못된 사용으로 인해 주로 발생합니다.

- **`OutOfMemoryError` 는 어떤 경우에 발생하나요?**

  - JVM 에서 힙 영역의 메모리를 다 사용했을 때 발생합니다. `new` 키워드로 객체를 생성하면 그 객체는 우선 힙 영역에 저장됩니다. 만약 힙 영역이 꽉 찼다면, Garbace collector 가 작동합니다. 만약 GC가 작동했음에도 불구하고 힙 영역에 새로운 객체를 할당할 공간이 없으면 `OutOfMemoryError`가 나타납니다.
  - 구체적인 상황으로는, 만약 `static` 키워드로 배열을 만들고, 그 안에 참조형 변수를 저장하면 객체는 힙 영역에 저장됩니다. 하지만 정적 영역에 저장된 배열은 jvm 이 종료되기 전까지 메모리가 해제되지 않습니다. 또한 정적 영역은 GC의 대상이 아니기 때문에 jvm 이 종료되기 전까지 힙 영역에 저장된 객체들은 참조하는 변수가 있는 reachable 객체로 간주됩니다. 따라서 GC 는 이 객체들을 제거할 수 없습니다. 만약 코드를 잘못 작성한다면 이러한 문제들이 생길 수 있습니다. 따라서 스태틱 영역에 넣을 때는 메모리 릭이 발생하지 않도록 프로그래머가 관리를 해야 합니다.
  - 또 다른 상황으로는 힙 영역이 모든 요청을 처리하기에는 공간이 작아서 발생할 수 있습니다. 만약 5만개의 요청을 처리하는 어플리케이션에 맞는 힙 영역을 할당했는데, 그보다 많은 요청이 들어오면 힙 영역이 부족해져서 `OutOfMemoryError`가 발생할 수 있습니다. 이러한 경우에는 jvm 을 종료하고 시작할 때 힙 영역의 사이즈를 늘려서 할당시켜줄 수 있습니다.

- **`StackOverflowError` 는 어떤 경우에 발생하나요?**

  - 스레드 내에서 메소드가 시작될 때, 필요한 스택 영역을 할당받습니다. 만약 메소드 안에서 다시 메소드를 실행하면, 또 스택 영역을 할당 받습니다. 이런 식으로 계속 메소드 내에서 메소드를 호출하면 스택 영역이 꽉 차게 되어 `StackOverflowError` 가 발생합니다. 흔히 재귀함수에서 `StackOverflowError` 가 발생합니다.

- **왜 체크 예외는 반드시 try-catch 문으로 처리해야고 언체크 예외는 처리하지 않아도 될까요?**
  - 자바는 과거에는 목적 자체가 서버를 위한 언어는 아니었습니다. 원래는 냉장고, 텔레비전 등 다양한 상황에서 사용하기 위해 만든 언어였습니다. 그러다 보니 예외가 발생했을 때 처리를 강제 해서 메인 함수가 종료되는 문제를 막고 안정성을 높이는 것이 중요했습니다. 따라서 체크 예외에서는 try-catch 를 강제했습니다. 하지만 현재 자바는 서버를 위한 언어로 가장 많이 쓰입니다. 이때도 프레임워크와 같이 사용합니다. 따라서 요즘은 체크 예외를 많이 쓰지 않고 다 런타임 예외로 처리를 하는 추세입니다.

### 14. 자바에서 쓰레드를 생성하는 방법에는 어떤 것들이 있나요?

첫번째 방법은 쓰레드 클래스를 상속받는 것입니다. 자손 클래스는 Thread 클래스의 `run()` 메서드를 오버라이드해야 합니다. 그러면 자손클래스의 객체는 할당받고 시작할 수 있습니다.

두번째 방법은 `Runnable` 인터페이스를 구현하는 클래스를 선언하고, 이 클래스를 Thread 클래스의 생성자의 매개변수로 제공하는 것입니다.

- **그렇다면 두 방법의 장단점은 무엇인가요?**

  - 쓰레드 클래스를 상속받으면, 쓰레드의 상태관리에 필요한 `start()` , `sleep()`, `join()` 을 바로 사용할 수 있습니다. 하지만 자바는 단일 상속만을 허용하기 때문에 쓰레드 클래스를 상속받으면 다른 클래스를 상속받을 수 없습니다. 또한 Thread 클래스를 상속받으면 Thread 클래스에 구현된 코드들에 의해 더 많은 자원(메모리와 시간 등)을 필요로 하므로 Runnable이 주로 사용됩니다.

- **`Runnable` 인터페이스의 용도는 무엇인가요?**

  - 쓰레드를 생성하고 매개변수로 Runnable 타입 객체를 넣으면, 그 안의 `run()` 메서드를 쓰레드 내에서 할 작업으로 처리하겠다는 의미입니다. 즉, Runnable 타입 객체는 `run()` 메서드를 통해 쓰레드에서 할 작업을 지정하는 방법입니다.

- **`Thread` 와 `Runnable` 의 단점 및 한계는 어떤 것이 있을까요?**

  - Thread 와 Runnable 을 직접 사용하는 것은 값의 반환이 불가능합니다. 또한 매번 쓰레드를 생성하고 종료하는 오버헤드가 발생하고, 쓰레드들의 관리가 어렵습니다.

- **왜 Thread 클래스의 `public static native Thread currentThread();` 는 static 으로 선언되어 있나요?**

  - `currentThread()` 메서드는 현재 쓰레드에 대한 정보를 제공하는 용도입니다. 이 정보는 하나의 Thread 객체 내에 국한되지 않으며, 전체 쓰레드 간 공유됩니다. 따라서 이 메서드를 static으로 접근하는 것이 합리적입니다.

- **쓰레드의 `start()` 과 `run()` 메서드는 어떤 차이가 있나요?**

  - main 메서드에서 `run()`을 호출하는 것은 새로 쓰레드를 생성하는 것이 아닌, 현재 실행하고 있는 메인 쓰레드에서 단순히 `run()` 함수를 호출하는 것입니다. 반면, `start()` 는 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택(call stack)을 생성한 다음 JVM이 `run()` 을 호출해서, 생성된 호출스택에 `run()` 이 첫번째로 올라가게 합니다.

- **아래 코드의 결과는 어떻게 될까요?**

  ```java
  class MyRunnable implements Runnable{
    public void run(){
      System.out.println("My Runnable is running");
      Thread currThread = Thread.currentThread();
      currThread.setName("thread in run method");
      System.out.println("Current thread in run : " + currThread.getName());
    }
  }

  class TestRunnable {
    public static void main(String[] args) {
      Thread thread = new Thread(new MyRunnable());
      thread.run();
      System.out.println("Current thread in main : " + Thread.currentThread().getName());
    }
  }
  ```

  - 실행과정을 보면, main 메서드가 메인 쓰레드에서 실행됩니다. 그 후 `MyRunnable` 이 target 인 새로운 쓰레드를 만들지만, thread.start() 를 통해 새로운 쓰레드를 시작하는 것이 아니라 단순히 새로운 쓰레드의 `run()` 메서드를 호출합니다. 따라서 `run()` 메서드 또한 메인 쓰레드에서 실행되며, `setName()` 에 의해 메인 쓰레드의 이름이 바뀌게 됩니다. 따라서 결과는 아래와 같이 나타납니다.

  ```text
  My Runnable is running
  Current thread in run: thread in run
  Current thread in main : thread in run
  ```

- **새로 생성된 쓰레드의 호출 스택은 언제 사라질까요?**

  - 새로운 호출 스택이 `start()` 에 의해 생기면, 새로운 호출 스택에 `run()` 이 가장 처음 올라가게 됩니다. 만약 `run()` 에서 호출한 함수들의 실행이 모두 끝나고, `run()` 의 수행도 종료되면 쓰레드의 호출스택은 비워지면서 사라지게 됩니다.

- **`Callable` 과 `Runnable` 의 차이는 무엇인가요? 왜 `Callable` 과 `Future` 인터페이스가 생겼나요?**

  - Thread 과 Runnable 을 직접 사용하는 방식은 한계점이 있었습니다. 쓰레드를 생성할 때 지나치게 저수준의 API에 의존했고, 값의 반환이 불가능합니다. 또한 매번 쓰레드 생성과 종료하는 오버헤드가 발생했고 쓰레드들의 관리가 어려웠습니다. 따라서 제네릭을 사용해 결과를 받을 수 있는 `Callable` 인터페이스가 추가되었습니다.
  - `Callable` 과 `Runnable` 둘 다 구현한 클래스의 인스턴스가 스레드에 의해 실행되게끔 설계되었다는 공통점이 있습니다. 그러나 `Runnable`은 결과를 반환하지 않으며 체크 예외를 던질 수 없습니다. 반면 `Callable`은 결과를 반환하며, 체크 예외를 발생시킬 수 있습니다.

- **`ExecutorService`, `Future` 는 각각 무엇이며 어떤 용도로 쓰이나요?**

  - `ExecutorService`는 자바에서 스레드풀을 생성하고 사용하는 간단한 방법을 제공합니다. `ExecutorService` 에 Task만 지정해주면 알아서 쓰레드풀을 이용해서 Task를 실행하고 관리합니다.
  - `Future` 인터페이스는 별도의 스레드에서 실행 중인 비동기 계산의 결과를 나타냅니다. 계산이 완료되었는지 확인하고, 계산 결과를 검색하거나, 필요한 경우 계산을 취소할 수 있는 방법을 제공합니다. 작업이 `ExecutorService`에 제출되면 작업의 결과를 나타내는 `Future` 객체를 반환합니다.

### 15. 쓰레드의 상태값에는 어떤 것들이 있나요?

<details>
<summary>쓰레드의 6가지 상태값</summary>

<img width="800" alt="image" src="https://github.com/ddoddii/Computer-Science-Study/assets/95014836/e48f67e0-4053-42e8-ac39-040190e38e9f">

</details>

쓰레드는 **New, Runnable, Blocked, Waiting, Time_Waiting, Terminated** 6가지 상태값이 있습니다.

- `NEW` : 쓰레드가 생성되고 아직 시작되지 않은 상태 (=아직 start() 가 호출되지 않은 상태)
- `RUNNABLE` : 쓰레드가 실행 중 또는 실행 가능한 상태
- `BLOCKED` : 동기화 블럭에 의해 일시정지된 상태 (lock 이 풀릴 때까지 기다리는 상태)
- `WAITING` : 다른 쓰레드가 어떤 액션을 취하길 무한정으로 기다리는 상태 (=다른 쓰레드가 notify(), nofifyAll() 하기를 기다림)
- `TIME_WAITING` : 다른 쓰레드가 어떤 액션을 취하길 기다리지만 기다리는 시간이 지정되어 있는 상태
- `TERMINATED` : 쓰레드의 작업이 종료된 상태

- **`WAITING` 과 `BLOCKED` 의 차이는 무엇인가요?**
  - `WAITING` 과 `BLOCKED` 모두 쓰레드가 일시 정지한 상태이지만, 원인이 다릅니다.
  - `WAITING` 상태의 쓰레드는 다른 쓰레드의 특정 액션을 기다리고 있습니다. 이 상태의 쓰레드는 특정 조건이 만족될 때까지 계속해서 대기합니다. `Object.wait()`, `Thread.join()` 를 호출하면 이 상태에 진입합니다.
  - 반면 `BLOCKED` 는 synchronized 블록이나 메서드에 진입하려고 시도할 때, 해당 락이 다른 쓰레드에 의해 보유되고 있으면 발생합니다. `BLOCKED` 상태의 쓰레드는 락을 보유하고 있는 쓰레드가 락을 해제할 때까지 기다립니다. 락이 해제되면, 대기하고 있는 쓰레드 중 하나가 락을 획득하고 RUNNABLE 상태가 됩니다.
- **왜 `sleep()` 과 `yield()` 는 static 메서드인가요?**
  - `sleep()` 과 `yield()` 는 둘 다 현재 실행 중인 쓰레드에 대해 작동합니다.
- **`yield()` 과 `join()` 의 차이점은 무엇인가요?**
  - `yield()` 는 현재 쓰레드가 다른 쓰레드에게 CPU 를 양보하고 싶을 때 사용합니다. 하지만 이 스케쥴러는 이 힌트를 무시할 수 도 있습니다.
  - `join()` 은 한 쓰레드가 다른 쓰레드의 종료를 기다리고 싶을 때 사용합니다. 예를 들어, 쓰레드 A에서 threadB.join()을 호출하면, 쓰레드 A는 쓰레드 B가 종료될 때까지 기다립니다.
- **`sleep()` 과 `wait()` 의 차이점과 공통점은 무엇인가요?**
  - `sleep(long millis)` 은 Thread 클래스에 있는 메서드로, 현재 실행 중인 쓰레드를 일정 시간동안 멈추게 합니다. 이때 **객체에 대한 monitor 을 잃지 않습니다**. `interrupt()` 또는 일정 시간이 지나면 다시 `RUNNABLE` 상태로 돌아옵니다.
  - `wait()` 은 Object 클래스에 있는 메서드로, 동기화 블록 내에서만 사용할 수 있으며 보다 효율적인 동기화를 가능하게 하기 위한 용도입니다. 동기화된 임계 영역의 코드를 수행하다 더 이상 작업을 진행할 상황이 아니라면, `wait()` 를 호출하여 **쓰레드가 락을 반납**하고 기다립니다. `notify()`, `notifyAll()` 또는 일정 시간이 지나면 다시 `RUNNABLE` 상태로 돌아옵니다.

### 16. 쓰레드의 동기화는 무엇이며, 동기화에 사용되는 방법들은 어떤 것이 있나요?

쓰레드의 동기화(synchronization) 란 **한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것**입니다. `synchronized` 를 이용한 방법, `wait()`와 `notify()` 를 이용한 방법, `java.util.concurrent.locks` 와 `java.util.concurrent.atomic` 패키지를 이용한 방법이 있습니다.

- **`synchronized` 에 의한 방법은 무엇이며, 어떤 장단점이 있을까요?**
  - 가장 간단한 방법으로, `synchronized` 를 사용하여 임계 영역(critical section)을 설정합니다. 쓰레드는 `synchronized` 블럭 내 객체의 lock 을 얻어 작업을 수행하다가 메서드가 종료되면 lock 을 반납합니다. lock 의 획득과 반납이 자동적으로 이루어지므로 간편하다는 장점이 있습니다. 하지만 만약 네트워크 I/O 를 기다리는 경우와 같이 객체가 락을 보유한 상태로 오랜 시간을 보낼 수 도 있다는 단점이 있습니다.
- **`wait()`와 `notify()` 를 이용한 방법은 무엇이며, 어떤 장단점이 있을까요?**
  - 위의 `synchronized` 의 단점을 보완하기 위한 방법이며, 동기화된 임계 영역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니면 `wait()` 를 호출하여 쓰레드가 락을 반납하고 기다립니다. 나중에 작업을 다시 진행할 수 있는 상황이 되면 `notify()` 를 호출해서 작업을 중단했던 쓰레드가 다시 락을 얻어 작업을 진행합니다.
  - `notify()` 가 호출되면, 해당 객체의 waiting pool 내에 있는 모든 쓰레드 중 임의의 쓰레드만 통지를 받습니다. 이때 계속 기다리는 쓰레드가 생기는 기아 현상(starvation) 이 발생할 수 있습니다. 이 때문에 `notifyAll()` 는 해당 객체의 waiting pool 내에 있는 모든 쓰레드에게 통지하지만, 모든 쓰레드가 lock 을 얻기 위해 서로 경쟁하는 경쟁 상태(race condition) 을 발생시킬 수 있습니다.
- **`java.util.concurrent.locks` 에 있는 Lock 과 Condition 은 위의 문제들을 어떻게 해결했나요?**
  - 특정 쓰레드들을 위한 Condition 들을 구분합니다. 예를 들어, 쓰레드A 를 위한 conditionA 를 생성하고, 쓰레드B 를 위한 conditionB 를 생성한 후, `await()` 과 `signal()` 을 통해 통지의 대상을 구분할 수 있습니다.
- **`volatile` 키워드는 어떻게 변수에 대한 읽기와 쓰기를 동기화하나요?**
  - `volatile` 키워드를 붙이면, 코어가 변수의 값을 읽어올 때 바로 메모리에서 읽어오기 때문에 캐시와 메모리 간 변수 값이 일치하지 않을 때 생기는 불일치를 방지할 수 있습니다.

### 17. `ConcurrentHashMap` 은 무엇이며 어떻게 thread-safe 를 보장하나요?

<details>
<summary>HashTable vs. ConcurrentHashMap</summary>

<img width="678" alt="image" src="https://github.com/ddoddii/Computer-Science-Study/assets/95014836/e5e139f8-7e11-46a3-b4c8-6126f7909be1">

</details>

우선 값을 읽어오는 `get()` 메서드는 락을 걸지 않습니다. 즉, 읽기 연산은 여러 쓰레드가 동시에 수행할 수 있으며, 값을 쓰거나 지우는 `put()`, `remove()` 연산과 동시에 수행될 수 있습니다.

값을 쓰는 `put()` 연산에 대해서는 부분적(=특정 버킷에 대해)으로 락을 획득합니다. `ConcurrentHashMap` 는 HashMap 전체에 락을 걸지 않고, 원자적 연산인 Compare and Swap(CAS)을 사용하여 선택적으로 bucket 에 lock을 겁니다. 즉, 해당 버킷에 접근하는 쓰레드끼리만 경쟁하도록 해서, 훨씬 더 많은 쓰레드가 동시에 해시맵에 접근할 수 있습니다.

`ConcurrentHashMap` 은 내부적으로 `Node<K,V>` 의 배열(buckets) 을 사용합니다. 키의 hashcode 는 버킷의 위치를 결정합니다.
`ConcurrentHashMap` 의 `putVal(K key,V value,boolean onlyIfAbsent)` 는 아래와 같이 동작합니다.

```text
1. 새로운 노드 값을 삽입하기 위해, 타깃 버킷의 값이 비어있는지 확인한다.
2. 버킷이 비어있다면 원자적 연산인 casTabAt() 을 사용하여 노드를 담고 있는 volatile 변수에 접근하고 이 변수가 null 임을 확인한 후 새로운 노드를 추가한다.
3. 버킷이 비어있지 않다면, synchronized 를 사용하여 다른 스레드가 접근하지 못하도록 lock 을 건다.
```

- **버킷이 비어있는 경우, 새로운 노드를 추가할 때는 어떻게 락을 걸지 않고 thread-safe 를 보장할 수 있나요?**

  - 버킷이 비어있는 경우에는 원자역 연산인 `casTabAt()` 을 사용합니다. 이 연산은 CPU가 노드를 담고 있는 변수가 null 인지 확인하고 업데이트하는 과정을 끊지 않고 하나의 명령어로 수행합니다. `casTabAt()` 는 Compare and Swap(CAS) 연산을 바탕으로 하는데, CAS는 특정 메모리 위치 값이 주어진 값과 동일할 경우 해당 메모리 주소를 새로운 값으로 교체하는 원자적 연산입니다. 따라서 원자적 연산으로 동시성 문제를 처리합니다.

### 18. 함수형 프로그래밍은 무엇이며, 왜 필요한가요?

함수형 프로그래밍은 함수의 동작에 의한 변수의 부수적인 값 변경을 원천적으로 배제함으로써 오류를 방지합니다. 따라서 안정적이고 예측 가능한 프로그래밍이 가능합니다.

- **함수형 프로그래밍의 특징을 설명해주세요.**

  - 부수효과가 없는 순수 1급 객체로 간주하여 파라미터로 넘기거나 반환값으로 사용할 수 있으며, 참조 투명성을 지킬 수 있습니다.
  - 부수효과를 제거한 함수들을 순수함수(Pure Function)이라고 합니다. 1급 객체는 변수나 데이터 안에 담을 수 있고, 파라미터로 전달할 수 있고, 반환값으로 사용할 수 있는 것들이 가능한 객체를 말합니다.
  - 함수형 프로그래밍은 대입문이 없기 때문에 기본적으로 한 번 값이 변수에 할당되고 나면 이후에 값이 변경되지 않습니다. 따라서 부수효과(side-effect)가 발생하지 않습니다. 이런 프로그램을 참조 투명성을 가졌다고 합니다.

- **자바에서는 어떻게 함수형 프로그래밍을 할 수 있나요?**

  - 자바에서는 함수형 인터페이스와 람다식을 제공합니다.

- **`@FunctionalInterface` 어노테이션의 역할은 무엇인가요?**

  - 함수형 인터페이스 위에 `@FunctionalInterface` 어노테이션이 붙어있으면, 해당 인터페이스가 추상 메서드를 1개 가진 함수형 인터페이스임을 컴파일 단계에서 확인합니다. 만약 2개 이상의 추상 메서드가 있으면 컴파일 단계에서 오류가 납니다. 따라서 위의 어노테이션이 붙은 함수형 인터페이스는 람다표현식을 사용하는데 신뢰할 수 있습니다.

- **람다식과 함수형 인터페이스의 관계는 무엇인가요?**

  - 함수형 인터페이스는 단 하나의 추상 메서드를 가진 인터페이스입니다. 이 단일 추상 메소드를 통해 람다식을 이 인터페이스의 구현으로 사용할 수 있습니다. 자바에서 람다식을 사용할 때, 컴파일러는 람다식을 함수형 인터페이스의 인스턴스로 변환하고, 람다식이 해당 함수형 인터페이스의 유일한 추상 메서드를 구현합니다. 이를 통해 자바에서 함수형 프로그래밍 스타일이 가능하게 합니다.

- **람다표현식과 익명클래스의 차이는 무엇인가요?**
  - 람다표현식은 메서드를 하나의 식으로 표현한 것입니다. 메서드를 람다식으로 표현하면 메서드 이름과 반환값이 존재하지 않기 때문에 이를 '익명함수' 라고도 합니다. `(매개변수) -> { 실행 코드 }` 형태로 사용됩니다.
  - 익명 클래스는 이름 없이 선언과 동시에 객체를 생성하는 방법입니다. 클래스 또는 인터페이스를 확장하거나 구현하여 사용됩니다. `new 인터페이스명() { 클래스 본문 }`의 형태로 사용됩니다.

```java
interface FunctionalInterface {
    public abstract void printSomething(String text);
}

public class FunctionalExample {
    public static void main(String[] args) {
        FunctionalInterface func1 = text -> System.out.println(text); // 람다표현식
        func1.printSomething("I am 람다");

        FunctionalInterface func2 = new FunctionalInterface() {
            @Override
            public void printSomething(String text) {
                System.out.println(text);
            }
        }; // 익명 클래스
        func2.printSomething("I am 익명 클래스");
    }

}

```

- **자바에서 미리 함수형 인터페이스를 정의해놓은 이유는 무엇인가요?**

  - 람다식을 만들 때마다 매번 함수형 인터페이스를 생성하는 것은 번거롭습니다. 따라서 자바에서는 미리 `Runnable`, `Supplier<T>`, `Consumer<T>`,`Function<T, R>`,`Predicate<T>` 등 자주 사용될 것 같은 함수형 인터페이스를 정의해 놓았습니다.

  ```java
  public class FunctionalEx1 {
      public static void main(String[] args) {
          Runnable runTask = () -> System.out.println("Hello, Lambda Expressions!");
          runTask.run();
      }
  }
  ```

  <details>
  <summary>자바에서 제공하는 함수형 인터페이스</summary>

  <img width="1117" alt="image" src="https://github.com/ddoddii/Computer-Science-Study/assets/95014836/b94d6027-4df8-4429-bf42-61da6a4b1c45">

  <img width="1060" alt="image" src="https://github.com/ddoddii/Computer-Science-Study/assets/95014836/5eac1464-b98b-47f4-beb0-610952eb3289">

  출처 : [함수형 인터페이스 표준 API 총정리](https://inpa.tistory.com/entry/%E2%98%95-%ED%95%A8%EC%88%98%ED%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-API)

  </details>

### 19. 자바에서 I/O가 느린이유는 무엇인가요?

- **운영체제에서 I/O는 어떻게 동작하나요?**

  - I/O 는 기본적으로 버퍼로부터 데이터를 넣고 빼는 것을 의미합니다.
  - 사용자 프로세스는 유저 스페이스에서 동작하기 때문에, 하드웨어에 직접적으로 접근할 수 없습니다. 따라서 OS에서 제공하는 **시스템 콜**을 사용해서 I/O 를 수행합니다.
  - 버퍼로부터 데이터를 가져오는 `read()` 에 대해 봅시다. 프로세스가 `read()` 시스템 콜을 요청합니다. 제어권이 유저모드에서 커널모드로 넘어가고, 커널은 우선 프로세스가 요청한 데이터가 이미 커널 캐시 영역 캐시 메모리에 존재하는지 확인합니다. 만일 데이터가 존재하면, 해당 데이터를 `read()` 함수 호출 시 전달받은 메모리 영역으로 복사합니다. 만약 캐시 메모리에 없다면, 커널은 디스크 컨트롤러에게 디스크로부터 데이터를 가져오라고 시킵니다. 디스크 컨트롤러는 DMA 를 이용해서 데이터를 커널 메모리의 버퍼에 씁니다. 디스크 컨트롤러가 버퍼를 다 채우면, 커널은 이 데이터를 프로세스가 명시한 버퍼로 복사합니다.
  - 하지만 커널 스페이스에서 유저 스페이스로 데이터를 복사하는 과정은 번거롭습니다. 디스크 컨트롤러에게 직접 유저 스페이스로 데이터를 보내라고 말하면 되지 않을까요? 이것을 가능하게 하는 것이 가상메모리입니다. 가상메모리는 2개 이상의 가상 주소가 하나의 물리적인 주소를 가리킬 수 있습니다. 커널 스페이스의 주소를 유저 스페이스 주소와 같은 물리적 주소로 매핑함으로써, DMA 는 유저와 커널 프로세스 모두에게 보이는 버퍼에 데이터를 채워 넣을 수 있습니다.

  <details>
    <summary>I/O 의 기본 동작 원리</summary>

  - Buffer Handling

    <img width="751" alt="image" src="https://github.com/ddoddii/Computer-Science-Study/assets/95014836/65744fb8-3893-4067-8132-7ceddd5e021a">

  - Virtual Memory

    ![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/d4afcb27-1685-4230-809b-09070be31a3d)

  </details>

- **자바 IO 패키지가 OS의 I/O 보다 훨씬 느린 이유는 무엇인가요?**

  1. OS의 I/O 에서는, 디스크에서 커널 메모리로 데이터를 옮길 때 CPU가 관여하지 않도록 커널에서 직접 DMA 를 사용해서, I/O 를 관리합니다. OS는 그 후 커널 버퍼에 데이터를 저장하고 사용하는 형태로 운영합니다. 반면 자바에서는 JVM이 그 커널 버퍼에 접속할 수 있는 방법이 없었습니다. 그렇다보니 커널 버퍼에 있는 내용을 JVM에서 사용하려면 유저 스페이스로 복사를 해야 했습니다. 이 복사하는 과정 때문에 OS I/O 보다 자바 IO 패키지가 느릴 수 밖에 없었습니다.
  2. 자바의 IO 패키지는 동기방식의 IO 만 제공했습니다. 따라서 블로킹이 되어서 스레드 자원을 낭비하는 경우가 생겼습니다. 이 때문에 자바 IO 가 느렸습니다.

- **자바에서 NIO 패키지는 왜 IO 패키지에 비해 속도가 빠른가요?**

  - IO 는 스트림 기반입니다. 스트림은 입력 스트림과 출력 스트림이 구분되어 있습니다. 반면 NIO 는 채널 기반으로, 스트림과 달리 양방향으로 입력과 출력이 가능합니다.
  - IO 에서는 출력 스트림이 1바이트를 쓰면 입력 스트림이 1바이트를 읽습니다. 하지만 이런 시스템은 대체로 느리기 때문에, 버퍼를 사용하여 여러 개의 바이트를 한꺼번에 입력받고 출력하는 BufferedInputStream, BufferedOutputStream 을 같이 사용하기도 합니다. 반면, NIO는 기본적으로 버퍼를 사용하여 입출력을 합니다.
  - IO는 블로킹 방식으로, 입력 스트림의 read() 또는 출력스트림의 write() 를 호출하면 데이터가 입력되기 전 또는 데이터가 출력되기 전까지 스레드는 블로킹됩니다. 이때 블로킹을 빠져나오는 유일한 방법은 스트림을 닫는 것입니다. 반면 NIO는 블로킹과 넌블로킹의 특징을 모두 가지는데, 블로킹 시 스레드를 interrupt 함으로써 빠져나올 수 있습니다. 넌블로킹은 입출력시 스레드가 블로킹되지 않는 것을 의미합니다.

- **그러면 IO 가 무조건 나쁜 것일까요?**

  - IO, NIO 각각의 trade-off가 있습니다. 만약 연결 클라이언트 수가 적고 전송되는 데이터가 대용량이며 순차적으로 처리될 필요성이 있는 경우 IO 로 서버를 구현하는 것이 좋습니다. 반면 NIO는 클라이언트 수가 많고, 하나의 입출력 처리 작업이 오래 걸리지 않는 경우 유리합니다.

### 20. 쓰레드풀의 용도는 무엇일까요?

- 쓰레드풀은 미리 일정 개수의 쓰레드를 생성하여 관리하는 기법입니다. 쓰레드풀을 사용하면 스레드 생성 및 소멸과 관련된 오버헤드를 줄이고 애플리케이션에서 실행되는 스레드 수를 제어할 수 있습니다. 자바에서 스레드는 운영체제의 리소스인 시스템 수준 스레드에 매핑되는데, 스레드를 제어할 수 없을 정도로 많이 생성하면 이러한 리소스가 빠르게 부족해질 수 있습니다.

### 21. 쓰레드 로컬(Thread Local) 은 무엇인가요?

여러개의 스레드가 존재할 때, **각 스레드 별로 필요한 정보를 저장할 수 있는 특별한 저장소**입니다. ThreadLocal 클래스는 오직 한 스레드에 의해 읽고/쓰여질 수 있는 변수를 생성합니다. 각각의 스레드는 살아있는 한 ThreadLocal에 접근할 수 있는 암묵적인 참조를 가집니다. 스레드가 종료되면 스레드 로컬 인스턴스들의 모든 복사본들은 GC의 대상이 됩니다.

가령 Thread A 가 ThreadLocal 변수( tLocal ) 에 접근하여 a 라는 문자를 저장한다고 합시다. 동시에 Thread B 에서 마찬가지로 tLocal 변수에 접근하여, b 라는 문자값을 저장한다고 할때, a 라는 문자를 b 가 덮어 버리는 것이 아니라, 각 스레드별 전용 저장소에 각각의 값이 저장됩니다. 즉 멀티 스레드 환경에서 공유 자원의 동시성 문제를 해결할 수 있게 되는 것(thread-safe)입니다.

- **상속가능한 스레드 로컬(Inheritable ThreadLocal) 은 무엇인가요?**

  - `Inheritable ThreadLocal` 클래스는 `ThreadLocal` 클래스를 확장하며, 부모 스레드에서 자식 스레드로 값을 상속할 수 있도록 합니다. 자식 스레드가 만들어졌을 때, 자식 스레드는 부모가 가지고 있는 상속 가능한 스레드 로컬 값들을 모두 물려 받습니다. 보통은 부모 스레드와 값이 같지만, 자식의 값을 오버라이딩할 수 도 있습니다.

- **상속가능한 스레드 로컬(Inheritable ThreadLocal) 은 왜 필요한가요?**

  - 요청을 처리하는 스레드가 오랜 특정 작업 때문에 기간 동안 점유되어 스레드 풀로 반환되지 않는다면 동시성이 떨어지게 됩니다. 이러한 문제를 해결하기 위해 요청의 작업들 중 일부는 비동기로 실행되도록 백그라운드 스레드로 위임시킬 수 있습니다. 그러면 백그라운드 스레드에서는 스레드 로컬에 저장된 값이 없게 되므로 문제가 생길 수 있으므로, 자바는 자식 스레드에게 스레드 로컬의 값을 위임시켜주는 상속 가능한 스레드 로컬(Inheritable ThreadLocal)을 제공하고 있습니다.

### 22. Stream 에서 Map,flatMap 과 Optional 에서 Map, flatMap은 무엇인가요?

- **Stream**

  - map

    - 스트림의 각 요소들에 Function 을 적용시키고,그 결과를 스트림의 형태로 반환합니다.
    - `<R> Stream<R> map(Function<? super T, ? extends R> mapper);`

  - flatMap

    - flatMap은 중첩된 스트림 구조를 한 단계 제거하고 하나의 스트림으로 단순화하는 역할을 합니다.
    - `<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);`

      ```java
      List<List<String>> listOfLists = Arrays.asList(
        Arrays.asList("a", "b"),
        Arrays.asList("c", "d")
      );
      Stream<String> flatStream = listOfLists.stream().flatMap(List::stream); // 모든 내부 리스트의 요소를 하나의 스트림으로 합칩니다.
      ```

- **Optional**

  - map

    - 스트림의 map과 동일한 형태로 다른 값으로 변환하는 과정입니다.

    ```java
    public <U> Optional<U> map(Function<? super T, ? extends U> mapper) {
          Objects.requireNonNull(mapper);
          if (!isPresent()) {
              return empty();
          } else {
              return Optional.ofNullable(mapper.apply(value));
          }
      }
    ```

  - flatMap

    - Optional의 `flatMap` 메소드는 Optional 객체의 값이 존재할 경우, 그 값을 사용하여 새로운 Optional 객체를 생성하는 함수를 적용하고, 그 결과를 반환합니다. 이 메소드는 중첩된 Optional 객체를 단일 Optional 객체로 평탄화할 때 사용됩니다.

    ```java
    public <U> Optional<U> flatMap(Function<? super T, ? extends Optional<? extends U>> mapper) {
          Objects.requireNonNull(mapper);
          if (!isPresent()) {
              return empty();
          } else {
              @SuppressWarnings("unchecked")
              Optional<U> r = (Optional<U>) mapper.apply(value);
              return Objects.requireNonNull(r);
          }
      }
    ```

- **Stream의 flatMap 과 Optional의 flatMap 의 동작이 다른가요?**

  - 근본적으로는 같은 연산입니다. 둘 다 원래 가지고 있던 객체에 중첩 개념을 하나 풀어주는 개념입니다. 이 연산을 잘 활용하면 체이닝이 끊기지 않게 개발을 잘 할 수 있습니다.

### 23. Servlet 이란 무엇인가요?

서블릿은 자바에서 웹 리퀘스트를 받았을 때 어떻게 웹 응답을 보낼지를 정의한 스펙입니다. 서블릿의 구현체들은 자바 프로그램을 이용하여 사용자의 요청에 따른 동적인 컨텐츠를 제공해줍니다.

<details>
<summary>서블릿</summary>

- CGI vs. Servlet
  <img width="734" alt="image" src="https://github.com/ddoddii/Computer-Science-Study/assets/95014836/e40669e0-fbac-428e-aaac-bd716be96340">

출처 : [Servlet, Tomcat, Apache, Nginx.. 이게 다 뭘까](https://medium.com/naverfinancial/servlet-tomcat-apache-nginx-%EC%9D%B4%EA%B2%8C-%EB%8B%A4-%EB%AD%98%EA%B9%8C-384cdeb9ad5)

- 서블릿 동작 방식

<img width="673" alt="image" src="https://github.com/ddoddii/Computer-Science-Study/assets/95014836/69872357-ece7-4a8e-9cd8-dac604c893cb">

출처 : [[JSP] 서블릿(Servlet)이란?](https://mangkyu.tistory.com/14)

</details>

- **서블릿 컨테이너의 구현체로는 어떤 것들이 있나요?**

  - 서블릿 컨테이너의 구현체로는 대표적으로 톰캣이 있습니다. 톰캣은 서블릿 컨테이너의 스펙을 준수해서 구현을 하고 있습니다. 정확히 설명하자면 톰캣과 서블릿 컨테이너가 1:1 동치는 아니고, 톰캣이 구현한 수많은 컴포넌트 중에 서블릿 컨테이너 컴포넌트도 있는 것입니다. 왜냐하면 톰캣을 서블릿 컨테이너 용도로 쓰지 않고 단순히 웹 서버용으로도 쓸 수 있기 때문입니다.

- **그렇다면 WAS와 서블릿 컨테이너는 같은 개념일까요?**

  - 정확히는 아닙니다. WAS는 그 어플리케이션의 동작을 담당하는 서버인데, 그 서버가 서블릿을 통해 구현될 수 도 있고, 다른 방식으로도 구현될 수 있습니다. 왜냐하면 서블릿도 리퀘스트를 처리하는 자바에서 하나의 방식일 뿐이고, 모든 기술이 서블릿을 가지고 리퀘스트를 처리하지는 않기 때문입니다.

- **서블릿이 위치해있는 Servlet Container가 클라이언트 요청을 어떻게 처리하나요?**

  1. 사용자가 서블릿을 필요로 하는 특정 URL에 해당하는 HTTP 요청을 보냅니다.
  2. 컨테이너는 요청 URL을 처리하기 위해서 서블릿이 필요하다는 것을 확인합니다.
  3. 컨테이너가 `HttpServletRequest`와 `HttpServletResponse`라는 객체를 생성합니다.
  4. 컨테이너가 요청 URL에 맵핑되는 서블릿을 찾고, 요청을 처리하기 위한 쓰레드를 생성(또는 할당 allocate)한 후, 앞서 만든 request 와 response 객체를 서블릿 쓰레드에 전달합니다.
  5. 컨테이너는 서블릿의 service() 메서드를 호출하고, 메서드 수행이 완료되면 컨테이너는 사용자에게 HTTP 응답을 반환합니다.

- **Web Container 란 무엇인가요?**

  - Web Container는 Web Application Server 내에서 동적인 컨텐츠를 제공해줍니다. WAS는 웹 서버와 웹 컨테이너를 포함하고 있는 개념으로, 동적 컨텐츠에 대한 요청이 들어왔을 때 `Web server -> Web container -> Servlets -> Web container -> Web server` 같은 흐름으로 클라이언트에게 응답을 반환합니다.
  - 클라이언트가 웹서버에 HTTP 요청을 보내면, 웹 컨테이너가 이 요청을 받아서 요청 URL에 해당하는 서블릿에 전달하며, 서블릿 쓰레드가 사용자의 요청을 처리한 후 웹 컨테이너를 통해 응답을 반환합니다.

  <details>
  <summary>WAS의 구조</summary>

  <img width="710" alt="image" src="https://github.com/ddoddii/Computer-Science-Study/assets/95014836/6aa9eeee-bc42-4ba8-ad59-adafba82f434">

  </details>

- **JSP(Java Server Pages)란 무엇인가요?**

  - JSP 도 서블릿의 일종입니다. JSP는 서블릿 기반의 스펙 위에 페이지를 더 쉽게 만들 수 있도록 제공해주는 기능을 추가한 것입니다. 따라서 JSP도 배포가 되고 나면 서블릿 형태로 변형이 되어서 실제로 배포가 됩니다.

    <details>
    <summary>서블릿과 JSP의 관계</summary>

    <img width="666" alt="image" src="https://github.com/ddoddii/ddoddii.github.io/assets/95014836/14979c2a-c10c-49d9-8de0-5a296ab616d7">

    </details>

### 24. 자바의 ExecuterService 란 무엇인가요?

`ExecutorService` 인터페이스는 `Executor`를 상속하고, 스레드의 실행을 관리하고 제어하는 데 도움이 되는 메서드를 추가했습니다.

> An Executor that provides methods to manage termination and methods that can produce a Future for tracking progress of one or more asynchronous tasks.

- **`Future` 인터페이스란 어떤 용도인가요?**

  - `Future` 는 비동기 연산의 결과를 나타냅니다. 따라서 연산이 완료되었는지 체크하고, 완료를 기다리고, 연산 결과를 가져오는 메서드들이 있습니다. 결과는 연산이 완료되었을 때 `get` 메서드만 사용해서 가져올 수 있습니다.
  - 비동기 작업을 실행시키는 메서드는 Future형 반환값을 내뱉고 이 Future형 반환값을 통해 나중에 작업이 완료되었을 때 `get` 메서드를 통해 작업의 결과를 받아올 수 있습니다. 하지만 `get` 은 블로킹 콜이기 때문에 주의해야 합니다.

- **`Executer` 인터페이스란 어떤 용도인가요?**

  - `Executer`는 Runnable 태스크를 실행하는 용도입니다. Runnable 인터페이스를 인자로 받고 반환값은 없는 `execute()` 메서드만 가지고 있습니다.

- **`Executer` 의 `execute()` 과 `ExecuterService`의 `submit()` 의 차이는 무엇인가요?**

  - `execute()` 는 Runnable 인터페이스만 인자로 받을 수 있으며, 반환값이 없습니다. 반면 `submit()` 는 Runnable, Callable 인터페이스 둘 다 받을 수 있으며 Future 객체를 반환합니다.

    <details>
    <summary>execute() vs. submit()</summary>

    <img width="534" alt="image" src="https://github.com/ddoddii/ddoddii.github.io/assets/95014836/4d288d73-0be9-4942-a4aa-36db347d84fe">

    </details>

- **`ThreadPoolExecutor` 의 용도는 무엇인가요?**
  - `ExecutorService`를 확장하며, 태스크를 쓰레드풀로 실행합니다. 이때 쓰레드풀의 사이즈 등 설정은 Executors 의 팩토리 메서드를 통해서 합니다.
  - Executors의 팩토리메서드에는 `Executors.newCachedThreadPool`(제한이 없는 쓰레드풀, 쓰레드는 자동으로 회수됨), `Executors.newFixedThreadPool`(고정된 사이즈의 쓰레드풀), `Executors.newSingleThreadExecutor`(싱글 쓰레드) 가 있습니다.

### 25. 캐릭터 인코딩은 왜 필요한가요?

컴퓨터가 'a' 와 같은 캐릭터를 이해하려면 바이너리로 바꿔주어야 합니다. 따라서 모두 같은 방식으로 변환하도록 정한 약속입니다. 따라서 아스키로 인코딩한 데이터를 utf-8 로 보면 데이터가 깨져보이는 현상이 발생합니다.

- **인코딩의 종류 중 완성형과 조합형은 무엇인가요?**

  - 완성형은 '김' 이라는 완성된 하나의 문자를 표현하는 방식이고, 조합형은 'ㄱ' + 'ㅣ' + 'ㅁ' 을 조합하여 표현하는 방식입니다.

- **아스키코드와 utf-8의 관계는 무엇인가요?**
  - 처음에는 알파벳을 인코딩하기 위해 아스키코드가 사용되었습니다. 하지만 점차 다른 나라의 문자들도 인코딩해야 했는데, 아스키코드는 1byte 를 사용하기 때문에 공간이 부족했습니다. 따라서 2byte를 사용하는 utf-8 이 생겼습니다. 여기서 미국 입장에서는 1byte 만 사용하면 될 것을 2byte 로 늘려야 하니, 호환성이라는 개념을 도입했습니다. utf-8을 따르되, 첫번째 1바이트 부분은 아스키 코드와 동일하게 가져갔습니다. 그리고 아스키 코드에서 쓰이지 않는 비트 1개를 사용해서 그 비트가 0으로 되어있으면 첫번째 1바이트만 쓰고, 1이면 다음 바이트까지 묶어서 하나의 문자로 표현하는 프로토콜로 정했습니다.
