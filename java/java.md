## Java

<details>
<summary>📚 공부한 자료</summary>

- 자바의 정석

</details>

### 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요. ⭐️

- **그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?**

- **반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?**

- **JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?**

- **Java bytecode란 무엇인가요?**

- **그렇다면 Java는 컴파일 언어일까요, 인터프리터 언어일까요?**

- **JVM의 동작 방식에 대해 간단하게 설명해주세요.**

- **JVM의 구조에 대해 설명해주세요.**

- **JVM의 Runtime Data Area 영역은 무엇인가요?**

- **JVM Stack 과 Heap 영역의 가장 큰 차이점은 무엇인가요?**

- **만약 두 개의 스레드가 동시에 힙에 있는 메모리에 접근할 때 동시성 문제가 생길 수 있습니다. 구체적인 예시로는 어떤 것이 있을까요?**

- **스레드이 메서드별로 스택이 할당 되는데, 메서드가 종료되게 되면 그 메서드 안에서 아용된 로컬 변수가 쓸모 없어지기 때문에 메모리 해제가 되는데, 만약 메서드 안에서 선언한 변수가 참조형 타입인 경우에는 어떤 식으로 메모리가 사용되나요?**

- **Java 메모리 영역 중 Stack 과 Heap 에는 각각 어떤 것이 저장되나요?**

- **기본형 데이터 타입과 참조형 데이터 타입의 실제 값은 각각 어느 영역에 저장되나요?**

- **그렇다면, `Person p = new Person()` 를 실행했을 때 `p` 와 `Person() 객체` 는 각각 어느 영역에 저장되나요?**

- **Java 메모리의 있는 스택 프레임은 메서드가 종료되면 사라집니다. 하지만 힙 영역에 있는 객체들은 메서드가 종료되도 메모리에 남아 있습니다. 왜 그럴까요?**

- **Static 영역과 Heap 영역의 공통점과 차이점은 무엇인가요?**

### 2. final 키워드를 사용하면, 어떤 이점이 있나요?

- **그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?**

### 3. 변수는 어떤 것인가요?

- **참조형 변수에서 실제 값을 저장하지 않고 주소값을 저장하는 이유는 무엇인가요?**

- **그렇다면 기본형 변수는 스택 영역 내에 실제 값을 저장하는 이유는 무엇인가요?**

- **변수와 상수의 차이는 무엇인가요?**

### 4. 부동소수점이 무엇인가요?

- **부동소수점을 사용하면, 소수 계산 오차 문제가 사라지나요?**

- **자바에서 실수형 계산을 정확하게 하기 위해서는 어떻게 해야 하나요?**

- **그렇다면 BigDecimal 은 실수를 어떤 형태로 저장하나요?**

### 5. `==` 과 `equals` 의 차이점은 무엇인가요?
두 연산은 비교하는 방식에서 차이를 가집니다. 
1. == 연산은 기본 타입의 경우,두 값의 값 자체를 비교합니다. 두 개의 int 변수가 같은 값을 가지고 있으면, 이 연산자는 true를 반환합니다.
    참조 타입에 대해서는, ==는 두 객체 참조가 메모리상 동일한 위치를 가리키는지를 확인하고 두 객체 참조가 실제로 같은 객체를 가리키는 경우에만 true를 반환합니다.
2. equals 메서드의 기본 구현은 == 연산자와 동일하게 참조 동등성을 검사하지만, 대부분의 클래스에서는 이 메서드를 오버라이드하여 객체의 논리적 동등성을 비교하도록 구현합니다.
- **Object 의 `equals` 메서드는 어떻게 구현되어 있나요?**
  - 기본 구현은 단순히 == 연산자를 사용하여, 두 객체 참조가 메모리상 동일한 객체를 가리키는지 비교하고 두 객체 참조가 실제로 같은 객체를 가리키고 있을 때만 true를 반환합니다. 그러나, 대부분의 경우 이 메서드를 오버라이드하여, 객체의 논리적 동등성을 기반으로 equals 메서드를 구현합니다.
- **아래의 코드는 어떤 결과가 나올까요? 이유를 설명해보세요.**

  ```java
  Integer a = new Integer(3);
  Integer b = new Integer(3);
  System.out.println(a==b);
  ```
  - 출력 결과는 false 입니다. new 키워드를 사용하여 객체를 생성하면, 항상 새로운 객체 인스턴스가 메모리에 할당됩니다. 메모리의 다른 위치에 Integer 객체를 생성하므로, a와 b는 물리적으로 다른 객체를 참조합니다.

- **그럼, `equals()` 와 `hashCode()` 에 대해 설명해 주세요.**

- **`hashCode()` 의 용도는 무엇인가요?**
  - hashCode() 메서드는 객체의 해시 코드를 반환합니다. 
- **본인이 `hashCode()` 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?**
  - equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 함을 가장 염두에 둬야한다 생각합니다. 또한, 성능도 고려해야 한다고 생각합니다. 너무 복잡하거나 시간이 많이 소요되는 연산을 포함하지 않도록 주의해야 하고, 클래스가 불변이고 해시코드를 계산하는 비용이 크다면, 매번 새로 계산하기 보다는 캐싱하는 방식을 고려하면 좋습니다..
- **그렇다면 `equals()` 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.**
  - 일관적으로 동등한지 여부를 판단할 수 있는 로직으로 작성하는 것이 가장 중요하다 생각합니다. 예를 들어, x.equals(y)가 true면 y.equals(x)도 true여야 하고, 참조 객체는 null 이 존재할 수도 있기 때문에 null과 관련한 검사도 염두에 두어야 합니다.
- **만약 `equals()` 와 `hashCode()` 를 둘 다 재정의 했을 때, 객체의 주소값을 비교해야 한다는 상황이 온다면 어떻게 하나요?**
  - hashCode() 메서드에서는 System.identityHashCode()를 사용하여 객체의 실제 주소값을 기반으로 해시 코드를 생성합니다. equals() 메서드에서는 객체의 주소값을 비교하여 동일한 객체인지를 확인합니다. 
    

### 6. 다형성은 무엇인가요? 또 언제 활용할 수 있을까요?

### 7. 인터페이스와 추상클래스의 차이점은 무엇일까요?
인터페이스는 완전 추상화라는 특성을 가지고, 추상 클래스는 부분적 추상화라는 특성을 가집니다.

인터페이스는 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해서 사용합니다. 모든 메서드가 추상 메서드이기 때문에 구현에 강제성이 부여됩니다.

추상 클래스는 하위 클래스들의 공통점을 모아 추상화하여 만든 클래스로 클래스간의 연관 관계를 구축하는 것에 초점을 둡니다. 하위 클래스들이 가진 공통적인 기능과 속성을 끌어올려 추상화합니다.
- **왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?**
  - 다중 상속이 가능한 경우, 여러 클래스로부터 상속받은 메서드나 필드가 충돌하여 모호성이 발생할 수 있는 문제가 생깁니다. 반면 인터페이스는 다중 구현에 대한 모호성이 없습니다.  구현되어야 하는 메서드의 명세만을 정의하고, 실제 구현은 해당 인터페이스를 구현하는 클래스에서 이루어집니다. 따라서 여러 인터페이스를 동시에 구현하는 것이 모호성을 발생시키지 않습니다.


- **인터페이스에서, `default method` 란 어떤 것인가요? 어떤 상황에서 주로 사용되나요?**
  - 인터페이스에서 default method는 인터페이스에 메서드를 구현하는 기능을 제공합니다. 기본 메서드는 인터페이스에서 구현하지 않아도 되며, 구현된 메서드를 상속받는 클래스에서 그대로 사용하거나 필요에 따라 재정의할 수 있습니다.
  - 기존 인터페이스에 새로운 메서드를 추가하여 기능을 확장하고 싶은 경우, 인터페이스를 확장하여 새로운 default method를 추가할 수 있습니다. 이는 기존의 코드를 변경하지 않고도 새로운 기능을 추가할 수 있는 장점을 제공합니다. 또한 여러 클래스에서 공통으로 사용되는 기능을 인터페이스의 default method로 구현하여 코드의 중복을 줄일 수 있습니다.
  

- **클래스A 가 인터페이스A, 인터페이스B 를 구현한다고 합시다. 만약 인터페이스A, 인터페이스B 에 동일한 시그니처를 가진 동일한 default method 가 있을 때, 다중 상속의 문제점이 발생하나요? 이것을 어떻게 해결하나요?**
  - 네 발생합니다. 이 때 다중상속의 모호성 문제를 해결하기 위해서는 자식 클래스에서 반드시 해당 메서드를 Override 해야합니다.
### 8. A 라는클래스에 특정코드를 주고 싶을때, 상속과 조합의 차이는 무엇이고, 각각의 장점을 설명해주세요.
상속은 하위 클래스가 상위 클래스의 특성과 기능을 상속받는 것이고 조합은 클래스가 다른 클래스의 객체를 포함하여 구성요소로 사용하는 것입니다. 
- 상속의 장점: 상속은 타입을 공유할 수 있다는 장점을 가집니다. 상위 클래스로 정의된 메서드나 필드를 하위 클래스에서도 그대로 사용할 수 있게 하므로, 하위 클래스는 상위 클래스로 정의된 인터페이스와 동일한 타입으로 취급될 수 있습니다. 이는 코드의 유연성을 높이고 타입 호환성을 유지하는 데 도움이 됩니다.
- 조합의 장점: 상속은 강한 결합이라는 단점을 가집니다. 이것은 캡슐화를 위반할 가능성이 높고 상위 클래스 변경에 따라 하위 클래스도 같이 변경할 리스크를 가집니다. 조합은 약한 결합을 가지기에 이러한 단점을 해결할 수 있습니다. 
### 9. 리플렉션에 대해 설명해 주세요.

- **의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?**

- **리플렉션을 언제 활용할 수 있을까요?**

### 10. static class와 static method를 비교해 주세요.

- **static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?**
- **컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.**

### 11. 자바에서 `new` 키워드를 사용하면 어떤 일이 일어나나요? 메모리 관점에서 자세히 설명해주세요.

### 12. 자바에서 스레드 풀(Thread Pool) 이란 어떤 것이고 언제 사용하나요?

### 13. Error 와 Exception 의 차이가 무엇인가요?

- **체크 예외와 언체크 예외의 차이는 무엇인가요?**

- **`OutOfMemoryError` 는 어떤 경우에 발생하나요?**

- **`StackOverflowError` 는 어떤 경우에 발생하나요?**

- **왜 체크 예외는 반드시 try-catch 문으로 처리해야고 언체크 예외는 처리하지 않아도 될까요?**

### 14. 자바에서 쓰레드를 생성하는 방법에는 어떤 것들이 있나요?

자바에서 스레드를 생성하는 방법은 두가지가 있습니다.
1. Thread 클래스를 상속받아 run 메소드를 오버라이딩 하는 방법입니다.
2. Runnable 인터페이스를 implements 하여 run 메소드를 정의하는 것입니다.

- **그렇다면 두 방법의 장단점은 무엇인가요?**
  - 자바에서는 다중 상속을 허용하지 않기 때문에, Thread 클래스를 확장하는 클래스는 다른 클래스를 상속받을 수 없습니다. 클래스의 확장성이 중요한 상황이라면 Runnable 인터페이스를 구현하는 것이 더 바람직할 것이다.
  - 반면 Thread를 확장하여 구현한 경우 해당 객체의 start() 메소드를 직접 호출할 수 있지만 Runnable을 구현한 경우 Runnable 형 인자를 받는 생성자를 통해 별도의 Thread 객체를 생성 후 start() 메소드를 호출해야 하기에 번거로움이 있을 수 있습니다.
  
- **`Runnable` 인터페이스의 용도는 무엇인가요?**
  - 멀티 스레딩을 위해 제공된 기술입니다.
  
- **왜 Thread 클래스의 `public static native Thread currentThread();` 는 static 으로 선언되어 있나요?**
  - 전역적인 접근과 스레드의 독립성을 보장하기 위해 static으로 선언되어 있습니다.
  - 전역적인 접근 : 모든 스레드에서 현재 스레드를 가져와야 할 때에는 인스턴스를 생성하지 않고도 접근할 수 있어야 합니다. static으로 선언함으로써 객체 인스턴스를 생성하지 않고도 메서드에 접근할 수 있습니다.
  - 스레드의 독립성 : currentThread() 메서드는 현재 실행 중인 스레드에 대한 정보를 제공하기 때문에, 이 메서드를 호출하는 스레드와 실제 반환되는 스레드가 서로 다를 수 있습니다. 따라서 인스턴스 레벨이 아닌 클래스 레벨에서 접근할 수 있도록 static으로 선언되어 있습니다.
- **쓰레드의 `start()` 과 `run()` 메서드는 어떤 차이가 있나요?**
  - run 메소드를 호출한다면 메인 스레드에서 객체의 메소드를 호출하는 것에 불과합니다. start() 메서드를 호출하는 것은 새로운 스레드가 작업을 실행하는데 필요한 호출 스택을 생성한 다음에 run을 호출해서 호출스택에 run이 올라가게 하는 것입니다.

- **아래 코드의 결과는 어떻게 될까요?**

  ```java
  class MyRunnable implements Runnable{
    public void run(){
      System.out.println("My Runnable is running");
      Thread currThread = Thread.currentThread();
      currThread.setName("thread in run method");
      System.out.println("Current thread in run : " + currThread.getName());
    }
  }

  class TestRunnable {
    public static void main(String[] args) {
      Thread thread = new Thread(new MyRunnable());
      thread.run();
      System.out.println("Current thread in main : " + Thread.currentThread().getName());
    }
  }
  ```
  출력 결과는 아래와 같습니다.
  ```text
  My Runnable is running
  Current thread in run : thread in run method
  Current thread in main : main
  ```
  TestRunnable 클래스의 main 메서드에서 새로운 스레드를 생성하여 MyRunnable 클래스의 인스턴스를 실행합니다. 그러나 스레드를 시작하는 대신에 run 메서드를 직접 호출하고 있습니다. 이 경우 스레드가 아닌 현재 실행중인 스레드에서 run 메서드가 실행됩니다.


- **새로 생성된 쓰레드의 호출 스택은 언제 사라질까요?**
  - 새로 생성된 스레드의 호출 스택은 해당 스레드가 실행을 마치고 종료될 때 함께 사라지니다. 스레드가 작업을 완료하거나 run() 메서드의 실행이 종료되면 해당 스레드는 종료됩니다. 이후에는 해당 스레드의 호출 스택도 메모리에서 해제 됩니다.
### 15. 쓰레드의 상태값에는 어떤 것들이 있나요?

스레드의 상태값으로는 6가지가 있습니다.
1. NEW
2. RUNNABLE
3. WAITING
4. TIMED WAITING
5. BLOCKED
6. TERMINATED

- **`WAITING` 과 `BLOCKED` 의 차이는 무엇인가요?**
  - WAITING은 다른 스레드가 특정 작업을 수행하기를 기다리는 상태입니다.
  - BLOCKED는 사용하고자 하는 객체의 락이 풀릴 때까지 기다리는 상태입니다.
  
- **왜 `sleep()` 과 `yield()` 는 static 메서드인가요?**
  - sleep(), yield() 메서드는 특정 스레드의 인스턴스가 아닌 현재 실행중인 스레드 그 자체를 대상으로 제어하는것입니다. 실행중인 상태가 아닌 스레드에 호출하는 것은 무의미하기에 이에 따라 정적 메서드로 선언되어야 합니다.
- **`yield()` 과 `join()` 의 차이점은 무엇인가요?**
  - yield()는 현재 실행중인 스레드가 자신에게 할당된 작업 시간을 양보함을 스케줄러에게 통보합니다.
  - join()은 현재 스레드를 일시정지 시킨 후, 특정 스레드가 일정 시간 동안 실행되도록 합니다.
- **`sleep()` 과 `wait()` 의 차이점과 공통점은 무엇인가요?**
  - sleep() 메서드와 wait() 메서드는 자바에서 스레드의 실행을 제어하는 데 사용되지만, 그 용도와 작동 방식에 있어서 차이점이 있습니다.
  - sleep() 메서드는 Thread 클래스의 정적 메서드입니다. 이에 반해, wait() 메서드는 Object 클래스의 일부로, 모든 객체에서 호출할 수 있습니다.
  - wait() 메서드는 동기화된(synchronized) 블록 또는 메서드 내에서만 호출될 수 있습니다. 이는 wait()가 호출된 객체의 모니터 락을 해제하고, 다른 스레드가 락을 획득할 수 있도록 기다리게 하기 때문입니다. 반면, sleep() 메서드는 동기화된 블록 없이 어디서나 호출될 수 있으며, 호출된 스레드를 일시 중지시키지만 모니터 락을 해제하지 않습니다.
### 16. 쓰레드의 동기화는 무엇이며, 동기화에 사용되는 방법들은 어떤 것이 있나요?

- **`synchronized` 에 의한 방법은 무엇이며, 어떤 장단점이 있을까요?**

- **`wait()`와 `notify()` 를 이용한 방법은 무엇이며, 어떤 장단점이 있을까요?**

- **`java.util.concurrent.locks` 에 있는 Lock 과 Condition 은 위의 문제들을 어떻게 해결했나요?**

- **`volatile` 키워드는 어떻게 변수에 대한 읽기와 쓰기를 동기화하나요?**

### 17. `ConcurrentHashMap` 은 무엇이며 어떻게 thread-safe 를 보장하나요?

- **버킷이 비어있는 경우, 새로운 노드를 추가할 때는 어떻게 락을 걸지 않고 thread-safe 를 보장할 수 있나요?**

### 18. 함수형 프로그래밍은 무엇이며, 왜 필요한가요?

- **함수형 프로그래밍의 특징을 설명해주세요.**

- **자바에서는 어떻게 함수형 프로그래밍을 할 수 있나요?**

- **`@FunctionalInterface` 어노테이션의 역할은 무엇인가요?**

- **람다식과 함수형 인터페이스의 관계는 무엇인가요?**

- **람다표현식과 익명클래스의 차이는 무엇인가요?**

- **자바에서 미리 함수형 인터페이스를 정의해놓은 이유는 무엇인가요?**

### 19. 자바에서 I/O가 느린이유는 무엇인가요?

- **운영체제에서 I/O는 어떻게 동작하나요?**

- **자바 IO 패키지가 OS의 I/O 보다 훨씬 느린 이유는 무엇인가요?**

- **자바에서 NIO 패키지는 왜 IO 패키지에 비해 속도가 빠른가요?**

- **그러면 IO 가 무조건 나쁜 것일까요?**
