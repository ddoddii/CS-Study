## 자료구조 & 알고리즘

<details>
<summary>📚 공부한 자료</summary>

- 파이썬 알고리즘 인터뷰

</details>

### **1. 시간복잡도와 공간복잡도에 대해 설명해 주세요.**

시간복잡도는 어떤 알고리즘을 수행하는데 걸리는 시간을 설명하는 계산복잡도이다. 대부분 알고리즘은 시간과 공간이 트레이드오프 관계이다. 

- **Big-O, Big-Theta, Big-Omega 에 대해 설명해 주세요.**
  - Big-O 는 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타낸다. 
  - Big-Omega 는 하한을 나타낸다.
  - Big-Theta 는 평균을 나타낸다. 
- **다른 것을 사용하지 않고, Big-O를 사용하는 이유가 있을까요?**
- **O(1)은 O(N^2) 보다 무조건적으로 빠른가요?**
  - N이 매우 작고, O(1) 이라고 해도 상수시간이 무지하게 크면 O(1) 보다 O(N^2) 이 더 빠를 수 있다.

### **2. 링크드 리스트에 대해 설명해 주세요.**

링크드 리스트는 데이터를 구조체로 묶어서 포인터로 연결합니다. 하지만 이것은 실제 데이터의 순서가 메모리에 물리적인 순서로 저장되는 것은 아닙니다. 

- **일반 배열과, 링크드 리스트를 비교해 주세요.**
  - 링크드 리스트는 배열과는 달리 특정 인덱스에 접근하기 위해서는 전체를 순서대로 읽어야 하므로 상수 시간에 접근할 수 없습니다. 탐색에는 O(n) 이 소요되지만, 시작 또는 끝 지점에 아이템을 추가하거나 삭제, 추출하는 작업은 O(1) 에 가능합니다. 
- **링크드 리스트를 사용해서 구현할 수 있는 다른 자료구조에 대해 설명해 주세요.**

### **3. 스택과 큐에 대해서 설명해 주세요.**

스택은 LIFO, 큐는 FIFO 방식입니다. 

- **스택 2개로 큐를, 큐 2개로 스택을 만드는 방법과, 그 시간복잡도에 대해 설명해 주세요.**
  - 스택 2개로 큐 만들기
    - 스택A,B 가 있다. 스택에 enqueue 할 때 스택A에 데이터를 넣는다. dequeue 할 때는 스택B에서 pop하는데, 만약 스택B가 비어 있으면 스택A에 있는 모든 데이터를 pop 해서 스택B로 옮긴다. 이 과정에서 스택A 에 저장되어 있던 데이터의 순서가 뒤집힌다. 
    - 데이터를 스택A -> 스택B 로 옮길 때 O(n) 이 걸리고, 나머지는 O(1) 로 가능하다. 
  - 큐 2개로 스택 만들기
    - 큐A,B 가 있을 때, 큐A에 원소들을 넣는다. 큐A에 원소가 1개 남을 때까지 큐A에서 get 한 원소를 큐B에 넣는다. 마지막 원소는 result 변수에 저장하고, 큐B에 있는 원소들을 다시 큐A로 이동한다. 이 과정을 반복하면 result 변수가 가장 마지막에 추가한 원소가 되어, LIFO 구조인 스택이 된다.  
- **시간복잡도를 유지하면서, 배열로 스택과 큐를 구현할 수 있을까요?**
- **Prefix, Infix, Postfix 에 대해 설명하고, 이를 스택을 활용해서 계산/하는 방법에 대해 설명해 주세요.**
- **Deque는 어떻게 구현할 수 있을까요?**
  - 덱(deque)은 double-ended queue의 줄임말로써 후단(rear)으로만 데이터를 삽입했던 기존 선형 큐, 원형 큐와 달리 큐의 전단(front)와 후단(rear)에서 모두 삽입과 삭제가 가능한 큐입니다. 원형큐, 배열, 링크드리스트로 구현 할 수 있다. 
- **(C++ 한정) Deque의 Random Access 시간복잡도는 O(1) 입니다. 이게 어떻게 가능한걸까요?**

### **4. 해시 자료구조에 대해 설명해 주세요.**

해시 함수는 임의의 길이의 데이터를 고정된 길이의 데이터로 변경해주는 역할을 한다. 이때 같은 입력 값에 대해서는 같은 출력값을 가진다. 해시 테이블에서는, 원래 데이터의 값을 해시함수를 이용해 해시 값으로 만든 다음 이 값을 인덱스로 사용한다. 따라서 인덱스의 해시값만 알면 되므로 모든 데이터를 탐색하지 않아도 된다. 따라서 검색이 O(1) 이다. 

- **값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?**
- **해시값이 충돌했을 때, 어떤 방식으로 처리할 수 있을까요?**
  - 해당 버킷에 이미 데이터가 있다면 링크드 리스트 방식으로 노드를 추가하여 다음 노드에 저장하는 방식인 Seperate Chaining 방법이 있다. 
- **본인이 사용하는 언어에서는, 어떤 방식으로 해시 충돌을 처리하나요?**
  - 파이썬의 경우에는 Open Addressing 방법을 사용한다. 이 방식은 충돌 발생 시 탐사를 통해 빈 공간을 찾는 방식이다. 가장 간단한 방식인 선형 탐사 방식은 충돌이 발생할 경우 해당 위치부터 순차적으로 탐사를 하나씩 진행한다. 그리고 해시 테이블이 일정 사이즈가 되면 사이즈를 늘리는 작업을 한다. 
- **Double Hashing 의 장점과 단점에 대해서 설명하고, 단점을 어떻게 해결할 수 있을지 설명해 주세요.**
- **Load Factor에 대해 설명해 주세요. 본인이 사용하는 언어에서의 해시 자료구조는 Load Factor에 관련한 정책이 어떻게 구성되어 있나요?**
- **다른 자료구조와 비교하여, 해시 테이블은 멀티스레드 환경에서 심각한 수준의 Race Condition 문제에 빠질 위험이 있습니다. 성능 감소를 최소화 한 채로 해당 문제를 해결할 수 있는 방법을 설계해 보세요.**

### **5. 트리와 이진트리, 이진탐색트리에 대해 설명해 주세요.**

트리는 노드들이 나무 가지처럼 연결된 계층적 자료구조이다. 가장 중요한 특징은  ‘루트노드를 제외한 모든 노드는 단 하나의 부모노드만을 가진다’는 것이다.  이진트리는 자식 노드가 최대 2개인 노드들로 구성된 트리이다. 이진탐색트리(Binary Search Tree)는 이진 트리 기반의 탐색을 위한 자료구조이다. BST에서, 왼쪽 서브 트리의 키들은 루트 키보다 작고 오른쪽 서브 트리의 키들은 루티 키보다 큽니다. 

- **그래프와 트리의 차이가 무엇인가요?**
  - 그래프는 노드와 노드 간을 연결하는 간선으로 연결된 자료구조이다. 순환 혹은 비순환 구조를 가질 수 있다. 반면 트리는 비순환 구조이다. 
- **이진탐색트리에서 중위 탐색을 하게 되면, 그 결과는 어떤 의미를 가지나요?**
  - 중위 순회(Inorder Traversal) 은 왼쪽 자식 → 자기 자신 → 오른쪽 자식 순서로 방문하기 때문에, 정렬된 순서대로 출력됩니다. 
- **이진탐색트리의 주요 연산에 대한 시간복잡도를 설명하고, 왜 그런 시간복잡도가 도출되는지 설명해 주세요.**
- **이진탐색트리의 한계점에 대해 설명해주세요.**
- **이진탐색트리의 값 삽입, 삭제 방법에 대해 설명하고, 어떤식으로 값을 삽입하면 편향이 발생할까요?**
- **이진탐색트리와 동일한 로직을 사용하면, 삼진탐색트리도 정의할 수 있을까요? 안 된다면, 그 이유에 대해 설명해 주세요.**

### **6. 힙에 대해 설명해 주세요.**

힙은 이진 트리에 Heap-order property(자식의 키가 부모의 키보다 크다), 완전 이진 트리의 2가지 조건을 추가한 자료구조이다. 따라서 삽입/삭제가 모두 O(logN) 이다. 최대힙은 자식 노드보다 부모 노드의 값이 크고, 최소힙은 자식노드보다 부모 노드의 값이 작다. 


- **힙을 배열로 구현한다고 가정하면, 어떻게 값을 저장할 수 있을까요?**
- **힙의 삽입, 삭제 방식에 대해 설명하고, 왜 이진탐색트리와 달리 편향이 발생하지 않는지 설명해 주세요.**
- **힙 정렬의 시간복잡도는 어떻게 되나요? Stable 한가요?**

### **7. BBST (Balanced Binary Search Tree) 와, 그 종류에 대해 설명해 주세요.**

균형 이진 탐색 트리란 노드의 삽입과 삭제가 일어나는 경우에 자동으로 그 높이를 작게 유지하도록 되어 있다. 대표적으로 AVL 트리 , 레드-블랙트리(Red-Black Tree) , B 트리, B+ 트리, B* 트리 들이 있다. 각 균형탐색트리마다 트리 높이의 균형을 잡기 위한 알고리즘들이 조금씩 다르다.

- **Red Black Tree는 어떻게 균형을 유지할 수 있을까요?**
- **Red Black Tree의 주요 성질 4가지에 대해 설명해 주세요.**
- **2-3-4 Tree, AVL Tree 등의 다른 BBST 가 있음에도, 왜 Red Black Tree가 많이 사용될까요?**

### **8. 정렬 알고리즘에 대해 설명해 주세요.**

- **Quick Sort와 Merge Sort를 비교해 주세요.**
- **Quick Sort에서 O(N^2)이 걸리는 예시를 들고, 이를 개선할 수 있는 방법에 대해 설명해 주세요.**
- **Stable Sort가 무엇이고, 어떤 정렬 알고리즘이 Stable 한지 설명해 주세요.**
- **Merge Sort를 재귀를 사용하지 않고 구현할 수 있을까요?**
- **Radix Sort에 대해 설명해 주세요.**
- **Bubble, Selection, Insertion Sort의 속도를 비교해 주세요.**
- **값이 거의 정렬되어 있거나, 아예 정렬되어 있다면, 위 세 알고리즘의 성능 비교 결과는 달라질까요?**
- **본인이 사용하고 있는 언어에선, 어떤 정렬 알고리즘을 사용하여 정렬 함수를 제공하고 있을까요?**
- **정렬해야 하는 데이터는 50G 인데, 메모리가 4G라면, 어떤 방식으로 정렬을 진행할 수 있을까요?**

### **9. 그래프 자료구조에 대해 설명하고, 이를 구현할 수 있는 두 방법에 대해 설명해 주세요.**

그래프는 노드와 노드 간을 잇는 간선으로 되어있는 자료구조이다. 인접 행렬, 인접 리스트로 구현 할 수 있다.

- **각 방법에 대해, "두 정점이 연결되었는지" 확인하는 시간복잡도와 "한 정점에 연결된 모든 정점을 찾는" 시간복잡도, 그리고 공간복잡도를 비교해 주세요.**
- **정점의 개수가 N개, 간선의 개수가 N^3 개라면, 어떤 방식으로 구현하는 것이 효율적일까요?**
- **사이클이 없는 그래프는 모두 트리인가요? 그렇지 않다면, 예시를 들어주세요.**

### **10. 그래프에서, 최단거리를 구하는 방법에 대해 설명해 주세요.**

- **트리에서는 어떤 방식으로 최단거리를 구할 수 있을까요? (위 방법을 사용하지 않고)**
- **다익스트라 알고리즘에서, 힙을 사용하지 않고 구현한다면 시간복잡도가 어떻게 변화할까요?**
- **정점의 개수가 N개, 간선의 개수가 N^3 개라면, 어떤 알고리즘이 효율적일까요?**
- **A\* 알고리즘에 대해 설명해 주세요. 이 알고리즘은 다익스트라와 비교해서 어떤 성능을 낼까요?**
- **음수 간선이 있을 때와, 음수 사이클이 있을 때 각각 어떤 최단거리 알고리즘을 사용해야 하는지 설명해 주세요.**

### **11. 재귀함수에 대해 설명해 주세요.**

재귀함수는 자기 자신(함수)를 계속적으로 콜하는 함수입니다. 함수가 콜 되면서 자신을 부른 원래 함수가 call stack 에 차곡차곡 쌓이게 됩니다. 처음 불려진 함수(스택 가장 밑에 있는 함수) 에서 return 되는 값이 최종 return 값이 됩니다. 

- **재귀 함수의 동작 과정을 Call Stack을 활용해서 설명해 주세요.**
- **언어의 스펙에 따라, 재귀함수의 최적화를 진행해주는 경우가 있습니다. 어떤 경우에 재귀함수의 최적화가 가능하며, 이를 어떻게 최적화 할 수 있을지 설명해 주세요.**

### **12. MST가 무엇이고, 어떻게 구할 수 있을지 설명해 주세요.**

- **Kruskal 알고리즘에서 사용하는 Union-Find 자료구조에 대해 설명해 주세요.**
- **Kruskal 과 Prim 중, 어떤 것이 더 빠를까요?**
- **Kruskal 과 Prim 알고리즘을 통해 얻어진 결과물은 무조건 트리인가요? 만약 그렇다면 증명해 주세요. 그렇지 않다면, 반례를 설명해 주세요.**

### **13. Thread Safe 한 자료구조가 있을까요? 없다면, 어떻게 Thread Safe 하게 구성할 수 있을까요?**

- **배열의 길이를 알고 있다면, 조금 더 빠른 Thread Safe 한 연산을 만들 순 없을까요?**
- **사용하고 있는 언어의 자료구조는 Thread Safe 한가요? 그렇지 않다면, Thread Safe 한 Wrapped Data Structure 를 제공하고 있나요?**

### **14. 문자열을 저장하고, 처리하는 주요 자료구조 및 알고리즘 (Trie, KMP, Rabin Karp 등) 에 대해 설명해 주세요.**

### **15. 이진탐색이 무엇인지 설명하고, 시간복잡도를 증명해 보세요.**

이진탐색은 정렬된 자료를 반으로 계속해서 나누어 탐색하는 방법이다. K번 시행 후에는 전체 자료 N개 중 $(1/2)^K*N$ 이 남는다. 계속해서 탐색하면 남는 자료의 개수가 1이 되고, $(1/2)^K*N \sim 1$ 이 된다. 이때 양변에 $2^K$ 를 곱해주면 $2^K \sim N$ 이 되고, 양변에 밑이 2인 로그를 취해주면 $K \sim \log_2{N}$ 이 된다. 따라서 자료의 개수 N에 따른 시행 횟수는 $\log_2{N}$ 이다. Big O 표기법으로는 $O(\log_2{N})$ 이다. 

- **Lower Bound, Upper Bound 는 무엇이고, 이를 어떻게 구현할 수 있을까요?**
- **이진탐색의 논리를 적용하여 삼진탐색을 작성한다고 가정한다면, 시간복잡도는 어떻게 변화할까요? (실제 존재하는 삼진탐색 알고리즘은 무시하세요!)**
- **기존 이진탐색 로직에서 부등호의 범위가 바뀐다면, (ex. <= 라면 <로, <이라면 <= 로) 결과가 달라질까요?**

### **16. 그리디 알고리즘과 동적 계획법을 비교해 주세요.**

Dynamic Programming(동적 계획법)은 전체 문제를 여러 개의 하위 문제로 나누어 풀고, 하위 문제들의 해결 방법들을 결합하여 최종 문제를 해결하는 문제 해결 방식이다.

 Greedy Algorithm은 문제를 해결하는 과정에서 그 순간순간마다 최적이라고 생각되는 결정을 하는 방식으로 진행하여 최종 해답에 도달하는 문제 해결 방식이다.

- **그렇다면, 어떤 경우에 각각의 기법을 사용할 수 있을까요?**
  - DP 같은 경우 반복되는 하위 문제들을 찾을 수 있을 경우에 사용한다. (eg. 피보나치 수열)
- **그렇다면, 동적 계획법으로 풀 수 있는 모든 문제는 재귀로 변환하여 풀 수 있나요?**
